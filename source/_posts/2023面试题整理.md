---
title: 2023面试题整理
date: 2023-02-21 16:31:32
tags: 面试题
categories:
- 面试题
---

## js 手写题

### 手写深拷贝

```js
function deepClone(obj = {}) {
  // 是null或者不是对象和数组 直接返回
  if (typeof obj !== "object" || obj == null) {
    return obj;
  }
  let result;
  if (obj instanceof Array) {
    result = [];
  } else {
    result = {};
  }
  for (let item in obj) {
    if (obj.hasOwnProperty(item)) {
      // 保证key不是原型的属性
      result[item] = deepClone(obj[item]);
    }
  }
  return result;
}

// 方法2
function deepClone(obj) {
    // 1 判断是否是非应用类型或者null
    if (typeof obj !== 'object' || obj == null) return obj
    // 2 创建一个容器
    let cloneObj = new obj.constructor()
    // 3 拿到对象的keys，给容器赋值
    Object.keys(obj).forEach(v => cloneObj[v] = deepClone(obj[v]))
    // 4 返回容器
    return cloneObj
}

```

### 手写 call apply bind 函数

```js
function call() {}
```

### 手写一个简易的jquery，考虑插件和扩展性

```js
class jQuery {
  constructor(selector) {
    const result = document.querySelectorAll(Selector);
    const length = result.length;
    for(let i=0;i<length;i++) {
      this[i] = result[i]
    }
    this.length = length
  }
  get(index) {
    return this[index]
  }
  each(fn) {
    for(let i=0;i<this.length;i++) {
      const elem = this[i];
      fn(elem)
    }
  }
  on(type,fn) {
    return this.each(elem => {
      elem.addEventListener(type,fn,false)
    })
  }
}

// 插件
jQuery.prototype.dialog = function(info) {
  alert(info)
}

// 造轮子
class MyJquery extends jQuery {
  constructor(selector) {
    super(selector);
  }
}
```

### 手写 new 函数

### 事件总线 | 发布订阅模式 event bus （EventMitter）

### 柯里化

```js
function myCurried(fn) {
  return function curry(...args1) {
    if (args1.length >= fn.length) {
      return fn.call(null, ...args1)
    } else {
      return function (...args2) {
        return curry.apply(null, [...args1, ...args2])
      }
    }
  }
}
```

### 去重

```js
// set
function unique(arr) {
  return [...new Set(arr)];
}
//filter
function unique(arr) {
  return arr.filter((item, index, array) => {
    return array.indexOf(item) === index;
  });
}
```

### instanceof

```js
function myInstanceof(target, origin) {
  if (typeof target !== "object" || target === null) return false;
  if (typeof origin !== "function")
    throw new TypeError("origin must be function");
  let proto = Object.getPrototypeOf(target); // 相当于 proto = target.__proto__;
  while (proto) {
    if (proto === origin.prototype) return true;
    proto = Object.getPrototypeOf(proto);
  }
  return false;
}
```

### 数组扁平化 
重点
```js
function flat(arr,depth = 1) {
  if(depth > 0) {
    return arr.reduce((pre,cur) => {
      return pre.concat(Array.isArray(cur) ? flat(cur,depth - 1) : cur)
    },[])
  }
  return arr.slice()
}
```

### 节流

```js
// 使用时间戳
function throttle(func, wait) {
  let preTime = 0;

  return function () {
    let nowTime = +new Date();
    let context = this;
    let args = arguments;

    if (nowTime - preTime > wait) {
      func.apply(context, args);
      preTime = nowTime;
    }
  };
}

// 定时器实现
function throttle(func, wait) {
  let timeout;

  return function () {
    let context = this;
    let args = arguments;

    if (!timeout) {
      timeout = setTimeout(function () {
        timeout = null;
        func.apply(context, args);
      }, wait);
    }
  };
}
```

### 防抖

```js
function debounce(func, wait, immediate) {
  let timeout;

  return function () {
    let context = this;
    let args = arguments;

    if (timeout) clearTimeout(timeout);
    if (immediate) {
      let callNow = !timeout;
      timeout = setTimeout(function () {
        timeout = null;
      }, wait);
      if (callNow) func.apply(context, args);
    } else {
      timeout = setTimeout(function () {
        func.apply(context, args);
      }, wait);
    }
  };
}
```

### 手写 reduce

```js
Array.prototype.reduce = function(cb,initialValue) {
  const arr = this;
  let total = initialValue || arr[0];
  for(let i = initialValue ? 0 : 1; i < arr.length; i++) {
    total = cb(total,arr[i],i,arr);
  }
  return total
}
```

### 实现简单的 promise

### 图片懒加载

### 异步控制并发数

### es5 和 es6 继承

### 数组排序

### 数组去重

### 获取 url 参数

## html&css 相关

### html语义化标签怎么理解

- 让人更容易读懂
- 让搜索引擎更容易读懂，有利于爬虫爬取更多的有效信息
- 没有css情况下，也能呈现很好的内容结构

### script 标签的 defer 和 async 区别

script: 会阻碍html解析，只有下载好并执行完脚本才会继续解析html
async script: 解析html过程中会进行脚本的异步下载，下载成功立马执行，有可能阻断html的解析 **异步下载，立即执行**
defer script: 完全不阻碍html的解析，解析完成后再按照顺序执行脚本 **异步下载，解析完执行**

### relative和absolute区别

1. 定位为relative的元素脱离正常的文本流中，但其在文本流中的位置依然存在，而定位为absolute的层脱离正常文本流，但与relative的区别是其在正常流中的位置不在存在（不占位置了）。
2. absolute不受父元素里的其他元素影响，而relative会受到父元素里的其他元素影响
3. relative相对的总是其**最近的父元素**，无论其父元素是何种定位方式，而absolute总是相对于最近**定义为absolute或relative的父层元素**

### 盒模型

两种盒模型：标准盒模型、IE盒模型
相同点：都是由 content + padding + border + margin构成
不同点：盒子内容的宽/高度
标准盒模型： 只包含content    box-sizin: content-box
IE盒模型： content + padding + border box-sizing: border-box

### 选择器及其优先级

!important > style(内联) > id > class

### reflow（重排/回流）和 repaint（重绘）理解

#### 重排/回流：
**第一次确定节点的大小和位置，称为布局，之后针对节点大小，位置改变重新计算称之为回流**
元素的**几何信息**被影响导致浏览器需要**重新计算**元素在视口内的几何属性（位置和尺寸）

#### 引发回流的几种情况
1. DOM结构发生变改变，如添加新的节点或者移除节点
2. 改变布局，如修改了width height padding font-size等值。
3. 改变窗口 resize,修改了窗口的尺寸。
4. 调用 getComputedStyle方法获取尺寸、位置信息。

#### 重绘：
**第一次渲染内容称之为绘制，之后重新渲染称之为重绘**
通过构造渲染树和重排（回流）阶段，我们知道了可见节点的样式和具体的几何信息，接下来将渲染树的每个节点转换为屏幕上的**实际像素**的阶段

#### 引发重绘的几种情况
修改背景色、文字颜色、边框颜色、样式等。

### 如何减少重排和重绘

- 最小化重绘和重排，修改样式尽量集中一次性修改
- 尽量避免频繁的操作DOM
- 批量操作DOM 比如读取某元素 offsetWidth 属性存到一个临时变量，再去使用，而不是频繁使用这个计算属性；又比如利用 `document.createDocumentFragment()` 来添加要被添加的节点，处理完之后再插入到实际 DOM 中
- 尽量避免通过 `getComputedStyle` 获取尺寸位置信息
- 使用 **absolute** 或 **fixed** 使元素脱离文档流，这在制作复杂的动画时对性能的影响比较明显
- 开启 GPU 加速，利用 css 属性 transform 、will-change 等，比如改变元素位置，我们使用 translate 会比使用绝对定位改变其 left 、top 等来的高效，因为它不会触发重排或重绘，transform 使浏览器为元素创建⼀个 GPU 图层，这使得动画元素在一个独立的层中进行渲染(每个合成层都是单独渲染的)。当元素的内容没有发生改变，就没有必要进行重绘

[参考](https://juejin.cn/post/6844903779700047885)

### BFC 的理解

block format context: 块级格式上下文

### 实现两栏布局（左侧固定和右侧自适应） 5 种

1. 浮动
左侧元素宽度固定，向左浮动，右边元素margin-left设为固定宽度，**width:auto**
2. 浮动
左边元素宽度固定 ，设置向左浮动。右侧元素设置 **overflow: hidden;** 这样右边就触发了 BFC ，BFC 的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。
3. flex
左边固定宽度，右边**flex:1**
4. 绝对定位
左边元素absolute，宽度固定，右边margin-left设为左边元素的宽度
5. 绝对定位
左边元素宽度固定，右边元素 absolute  定位， left  为宽度大小，其余方向定位为 0

### 实现圣杯布局和双飞翼布局（三分栏）

#### 目的：
1. 三栏布局，中间一栏最先加载和渲染（内容最重要，中间内容在html中最先写好从而最先加载）。
2. 两侧内容固定，中间内容随着宽度自适应。
3. 一般用于 PC 网页。

#### 技术总结
1. 使用 float 布局。
2. 两侧使用 margin 负值，以便和中间内容横向重叠。
3. 防止中间内容被两侧覆盖，圣杯布局用(父元素) padding ，双飞翼布局用（子元素） margin 

### 水平垂直居中的实现

1. 绝对定位 **不需要管宽高**
```css
.father {
  position: relative;
}
.son {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
}
```

2. 绝对定位 各方向为0 margin设为auto  盒子必须有宽高
```css
.father {
  position: relative;
}
.son {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0px;
  margin: auto;
  height: 100px;
  width: 100px;
}
```
3. 绝对定位 left和top定位之后通过margin-left和margin-top修改  必须有宽高
```css
.father {
  position: relative;
}
.son {
  position: absolute;
  left: 50%;
  top: 50%;
  width: 200px;
  height: 200px;
  margin-left: -100px;
  margin-top: -100px;
}
```
4. flex 不定宽高
```css
.father {
  display: flex;
  justify-content: center;
  align-items: center;
}
```

### flex：1 的含义

TODO:背

flex-grow: 1 ：该属性默认为 0 ，如果存在剩余空间，元素也不放大。设置为 1  代表会放大。
flex-shrink: 1 ：该属性默认为 1 ，如果空间不足，元素缩小。
flex-basis: 0% ：该属性定义在分配多余空间之前，元素占据的主轴空间。浏览器就是根据这个属性来计算是否有多余空间的。默认值为 auto ，即项目本身大小。设置为 0%  之后，因为有 flex-grow  和 flex-shrink  的设置会自动放大或缩小。在做两栏布局时，如果右边的自适应元素 flex-basis  设为 auto  的话，其本身大小将会是 0 .

### line-height 如何继承

TODO:背

1. 父元素的 line-height 写了具体数值，比如 30px，则子元素 line-height 继承该值。
3. 父元素的 line-height 写了比例，比如 1.5 或 2，则子元素 line-height 也是继承该比例。
3. 父元素的 line-height 写了百分比，比如 200%，则子元素 line-height 继承的是父元素 font-size * 200% 计算出来的值。

## js 相关

### 值类型和引用类型的区别

值类型的变量直接存储数据（**栈**上），而引用类型的变量持有的是数据的引用（地址），数据存储在数据**堆**中。

引用类型：当**声明**一个类时，只在**栈**中分配一小片内存用于容纳一个地址，而此时并没有为其分配堆上的内存空间。当使用 **new** 创建一个类的实例时，分配**堆**上的空间，并把堆上空间的地址保存到栈上分配的小片空间中。


### typeof 能判断哪些类型

所有类型：undefined null(特殊引用类型，指向空地址) string number boolean symbol function(特殊引用类型)

1. 识别所有值类型
2. 识别函数 返回 'function'
3. 判断是否是引用类型

注意： typeof null | [1,2]  => "object"

### === 和 == 的区别
== 只要求值相等即可 即经过类型转换为同一类型后值相等即可
=== 不仅值相等 类型也要相同

使用过程中，除了 == null 之外，其他一律用 === 
if(obj.a == null) 等价于 if(obj.a === null || obj.a === undefined)

truly变量： !!a === true的变量
falsely变量  !!a === false的变量 ( 0 NaN "" null undefined false )

逻辑判断：
10 && 0 前面是truly值，&&直接返回后面的值
"" || 'abc' 前面是falsely值， ||直接返回后面的值

### 为啥 0.1+0.2 ！== 0.3

是由于浮点数运算的精度问题（精度是有限的）导致等式左右的结果不严格相等
浮点数转成二进制是无限循环的，所以计算机中只能存储一个近似值

正确的比较方法 是使用js提供的最小精度值 Number.EPSILON
`Math.abs(0.1+0.2-0.3) <= Number.EPSILON`

### 原型及原型链

原型：
每个class都有显式原型prototype
每个class实例化后的对象都有隐式原型__proto__
实例的隐式原型指向对应class的显式原型
class类具有定义的属性和方法，也有显式原型prototype。而将这个class类实例化后就有了隐式原型__proto__，即shilihua.proto === Student.proptotype

原型链：
首先，每个对象在初始化的时候都会被添加上__proto__属性，指向该对象的原型对象，同时在js中万物皆对象，所以该对象的原型对象也有__proto__属性指向它的原型对象，这样一直指下去就会形成一个原型形成的链，简称原型链。

### 如何判断一个变量是不是数组

param instanceof Array (return true/false)

xialuo instanceof Student  (true)

### class的原型本质，怎么理解

TODO:原型和原型链的图示

class可以理解为一个模板，本质就是一个函数，通过constructor构造方法来构造一些属性和方法，然后通过new关键字来实例化这个类
继承： 子类在自身的constructor方法中用super关键字调用父类的constuctor方法

### js的几种继承方式

TODO:

- 原型继承：

优点：通过原型继承多个引用类型的属性和方法

缺点：Sub原型变成了Super的实例，如果Super的实例某个属性是引用值，该引用值就会被应用到所有Sub创建的实例中去，会有污染问题。

- 盗用构造函数

优点：每个实例都会有自己的a属性，哪怕是引用值也不会被污染

缺点：Super构造函数中的方法在每个实例上都要创建一遍（除非该方法声明提到全局）

- 组合继承

优点： 集合了原型继承和盗用构造函数继承的优点

缺点：存在效率问题，Super始终会被调用两次

- 原型式继承

优点：对一个对象进行浅克隆创建另一个对象，同时继承该对象的原型属性

缺点：由于是浅克隆，所以实例共享的对象属性如果是引用值，会受污染

- 寄生式继承

优点：根据一个对象克隆创建另一个对象，并增强对象

缺点：同【盗用构造函数继承】方法在每个实例上都要创建一遍

- 寄生式组合继承

优点：集合了【原型式继承】和【盗用构造函数继承】的优点，效率比【组合继承】更高。

### 作用域和作用域链

作用域（scope） ：当前的**执行上下文**，作用域就是一个独立的地盘，让变量不会外泄、暴露出去。作用域最大的用处就是**隔离变量**，不同作用域下的同名变量不会有冲突。

- 全局作用域 （最外层定义的变量和函数，未定义并直接赋值的变量-变量提升，window对象的属性）
- 函数作用域 （函数内部定义的变量）
- 块级作用域 （let const声明的变量）

作用域链

- 自由变量 当前作用域中没有定义的变量，称为自由变量。
- 作用域链  访问变量时，自己的作用域中没有，一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃，这种一层一层的关系，就是作用域链
- 作用域与执行上下文的区别
  - 解释阶段（作用域规则确定）
  - 执行阶段（执行上下文）

执行上下文在运行时确定（this的指向问题），随时可能改变，作用域（变量的值）在定义时就确定，并且不会改变。


### 执行上下文

是js代码执行的一个环境，存放了代码执行所需的变量，变量查找的作用域链规则以及this指向等

### 闭包

1. 有权访问其他函数作用域中变量得函数

2. 闭包是指那些能够访问自由变量的函数。 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。 闭包 = 函数 + 函数能够访问的自由变量

所有（闭包）自由变量的查找 是在函数定义的地方，向上级作用域查找 不是在执行的地方

#### 怎么创建闭包

在一个函数内部创建另一个函数

#### 闭包的作用

可以阻止变量被回收 

#### 闭包的缺点

比普通函数更加占用内存，可能造成内存泄漏，不会被垃圾回收机制回收

#### 闭包的实际应用场景

循环绑定监听事件,给标签循环添加监听事件 
解决方式：1. 立即执行函数 2. es6声明 let const等（如下）
```js
let a,i
for(i=0;i<10;i++) {
  // 这里面的i都是10
}
// 正确写法
let a
for(let i=0;i<10;i++) {
  // 这里都是块级作用域
}
```

### 垃圾回收机制

任务：找到**哪些被分配的内存确实已经不再需要了**

1. 引用计数垃圾收集
理解为 对象有没有其他对象引用它，如果没有就标记为**零引用**，对象将被垃圾回收机制回收
限制：循环引用的风险

2. 标记-清除算法
理解为 对象是否可以获得 假定设置一个root对象，垃圾回收器会定期从根开始找所有从它开始引用的对象，如果从全局对象无法获取的对象则会被垃圾回收器回收
限制: 那些无法从根对象查询到的对象都将被清除（一般没问题）


### this 的用法及含义

**this取什么值是在函数被执行的时候确定的，不是在定义的时候**

this的指向问题
1. 作为普通函数 window
2. 使用call bind apply （call可直接换this指向 bind是有返回值 返回值再调用）
3. 作为对象方法被调用 指代的就是这个对象本身
4. 在class方法中调用 当前实例本身 setTimeout注意
5. 箭头函数  `()=>{this}` 和上级作用域的值一致

### web 存储

1. cookie
   1. 特点
      1. 本身用于浏览器和server通讯
      2. 可用`document.cookie = 'xxx'`来修改
   2. 缺点
      1. 存储大小限制为4KB
      2. http请求需要发送到服务端，增加请求数量
      3. 只能用document.cookie修改
2. localStorage 和 sessionStorage
   1. 特点
      1. 最大可存储 5MB
      2. api 简单易用，setItem getItem
      3. 不会跟随 http 请求发送给服务端
   2. 区别
      1. localStorage 会永久存储，除非手动删除
      2. sessionStorage 数据只存在当前会话，浏览器关闭则清空
      3. 一般用 localStorage 较多

### http 缓存（强制缓存 | 协商缓存）

#### 为什么需要缓存？ 

网络请求相比于 CPU 的计算和页面渲染是非常非常慢的。

#### http缓存机制
http 缓存机制主要在http相应头中设定，响应头中相关字段为 Expires,Cache-Control,Last-Modified,If-Modified-Since,Etag 等
1. Expires
2. Cache-Control
   1. max-age：用来设置资源（representations）可以被缓存多长时间，单位为秒
   2. s-maxage：和max-age是一样的，不过它只针对代理服务器缓存而言；
   3. public：指示响应可被任何缓存区缓存；
   4. private：只能针对个人用户，而不能被代理服务器缓存；
   5. no-cache：强制客户端直接向服务器发送请求,也就是说每次请求都必须向服务器发送。服务器接收到请求，然后判断资源是否变更，是则返回新内容，否则返回304，未变更。这个很容易让人产生误解，使人误以为是响应不被缓存。实际上Cache-Control: no-cache是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。
   6. no-store：禁止一切缓存（这个才是响应不被缓存的意思）。

#### 强制缓存
过程：
1. 初次请求，服务器返回资源和cache-control
2. 再次请求，本地缓存直接返回资源

cache-control

#### 协商缓存（对比缓存）
- 服务端缓存策略。
- 服务端判断客户端资源，是否和服务端资源一样。
- 一致则返回 304，否则返回 200 和最新的资源。
过程：
1. 初次请求，服务器端返回资源和资源标识
2. 再次请求时带着资源标识，服务器端返回304，或返回资源（200）和新的资源标识

资源标识：保存在Response Headers中
1. Last-Modified： 资源的最后修改时间
2. Etag： 资源的唯一标识

##### Last-modified  If-Modified-Since
服务端拿到 if-Modified-Since 之后拿这个时间去和服务端资源最后修改时间做比较，如果一致则返回 304 ，不一致（也就是资源已经更新了）就返回 200 和新的资源及新的 Last-Modified。
##### Etag  If-None-Match
其实 Etag 和 Last-Modified 一样的，只不过 Etag 是服务端对资源按照一定方式（比如 contenthash）计算出来的唯一标识，就像人类指纹一样，通过 **If-None-match**（就是Etag的值） 传给客户端之后，客户端再传过来时候，服务端会将其与现在的资源计算出来的唯一标识做比较，一致则返回 304，不一致就返回 200 和新的资源及新的 Etag。

#### 总结
Etag的优先级比last-modified高

last-modified的不足：
1. 只能精确到秒级，如果一个文件一秒内多次修改，不能准确标注文件的修改时间
2. 如果一个文件定期生成且内容没有变化，last-modified也会改变，导致无法使用缓存

### 异步

异步就是当某一代码执行异步过程调用发出后，这段代码不会立刻得到返回结果，而是在异步调用发出之后，一般通过回调函数处理这个调用之后拿到结果。异步调用发出后，**不会影响阻塞**后面的代码执行

1. 最开始实现异步都是采用**回调函数**实现的，但是有个缺点：回调地狱
2. 为了解决回调地狱的问题，ES6提出了Promise的方式 （Generator配合yield方式）
3. ES7又提出新的异步解决方案 async/await async是Generator函数的语法糖，优点是使异步逻辑的代码跟同步一样容易理解

### promise

TODO:实现一遍Promise A+规范

### event loop

异步任务不进入主线程，而是进入**任务队列**，当主线程中的任务执行完毕，就从任务队列中取出任务放进主线程中来进行执行。由于主线程不断重复的获得任务、执行任务、再获取再执行，所以这种机制被叫做事件循环。

1. event loop过程1
   1. 同步代码，一行一行放在call Stack（执行栈）执行
   2. 遇到异步，会先记录下并交给其他线程处理，等待时机（定时，网络请求）
   3. 时机到了，就会移动到callback queue
2. event loop过程2
   1. 如果call stack为空（同步代码执行完），event loop开始工作
   2. 轮训查找callback queue，如果有则移动到call stack
      1. 优先检查微任务队列是否有任务，没有的话再去宏任务队列检查
   3. 然后继续轮训查找

另一种说法：
1. 执行一个宏任务（栈中没有就从事件队列中获取）
2. 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
4. 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
5. 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）

总结：
1. tasks 按序执行，浏览器会在 tasks 之间执行渲染。
2. microtasks 按序执行，在下面情况时执行：
   1. 在每个回调之后，只要没有其它代码正在运行。
   2. 在每个 task 的末尾

### 宏任务微任务

异步任务队列不只一个，根据任务种类分为微任务队列(micro task/ Task)和宏任务队列(macro task/Jobs)

宏任务 -（当前微任务） - 渲染 - 宏任务 。。。

**微任务比宏任务执行时间要早**

常见宏任务：
1. setTimeout
2. setInterval
3. setImmediate(Node)
4. 点击事件或键盘事件 i/o事件
5. Ajax
6. script整体代码段
7. promise里面的代码

常见微任务
1. **promise.then**,**await**（与then类似）,promise.catch
2. object.observe
3. new MutationObserver(浏览器环境)
4. process.nextTick(node)

注意：async函数在await之前的代码都是**同步**执行的，可以理解为await之前的代码属于new Promise传入的代码，**await之后的代码都是在Promise.then中的回调**

### 柯里化

柯里化就是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术

```js
function sum(a,b,c) {
  return a+ b + c
}
// 柯里化之后
function sum(a) {
  return function(b) {
    return function(c) {
      return a + b + c
    }
  }
}
// 调用时
sum(1)(2)(3)
```

#### 柯里化的好处
我们处理函数时，希望函数功能尽可能单一

#### 自动柯里化
(个人感觉不重要，理解什么是柯里化即可)
```js
function myCurried(fn) {
  return function curry(...args1) {
    if (args1.length >= fn.length) {
      return fn.call(null, ...args1)
    } else {
      return function (...args2) {
        return curry.apply(null, [...args1, ...args2])
      }
    }
  }
}

function sum(a, b, c, d, e) {
  return a + b + c + d + e
}
let resFunc = myCurried(sum)
console.log(resFunc(1,3,4)(1)(23))
//解析:
//1、这里的fn.length获取的是函数传入参数的长度
//2、这里使用递归的思想
```

### 箭头函数的优缺点

#### 优点
1. 简写了函数
2. **改变this的指向为当前外部对象**

#### 缺点
1. 没有arguments参数
2. 无法通过apply bind call来改变this的指向

#### 不能用于哪些场景
1. 不能用于对象方法
2. 不能用于对象原型
3. 不能用于构造函数
```js
const obj = {
    a:'a'
    getA: () => {
        return this.a
    }
}
console.log( obj.getA() ) //undefined
```


### 前端性能优化的措施

[参考](http://www.pczh.cn/news/22013.html)
#### 代码层面
1. 减少请求数量
   1. **图片处理**
      1. 雪碧图
      2. Base64
      3. 使用字体图标
   2. 减少重定向
   3. **使用缓存**
   4. **不使用CSS @import**
   5. 避免使用空的src和href
2. 减小资源大小
   1. **压缩 html css js 和图片均可压缩**
   2. **使用webp格式的图片**
   3. **开启gzip**（www服务器中安装的功能，用来压缩网页内容后传输到来访的电脑浏览器中）
3. 优化网络连接
   1. **使用CDN**
   2. 使用DNS预解析 （DNS Prefetch，即DNS预解析就是根据浏览器定义的规则，提前解析之后可能会用到的域名，使解析结果缓存到系统缓存中，缩短DNS解析时间，来提高网站的访问速度） `<link rel="dns-prefetch" href="xxx">`
4. 优化资源加载
   1. **资源加载位置**
      1. css放在head中，先外链，再本页
      2. js放在body底部，先外链，再本页
      3. 处理页面及页面布局的js'文件放在head中，如flexible.js
      4. body中尽量不写style和script标签
   2. **资源加载时机**
      1. 异步script标签
         1. defer html解析完开始执行
         2. async js加载完成后立即执行
      2. 模块按需加载
      3. 使用资源预加载preload和资源预读取prefetch
      4. 资源懒加载和资源预加载
5. 减少重绘回流
   1. 避免使用层级较深的选择器
   2. 避免使用CSS表达式，计算频率太高
   3. **元素适当的定义高度或设置最小高度，以免动态载入内容时出现页面元素晃动**
   4. **给图片设置尺寸，不然从0到有会位移，产生回流**
   5. **能用css实现就不要用js实现**
   6. 对需要多次重绘的元素独立为render layer渲染层，设置absolute
6. DOM优化
   1. 缓存DOM `const div = document.getElementById('div')`
   2. 减少DOM深度
   3. **批量操作DOM** 比如先拼接完字符串再更新DOM
   4. **事件代理**
   5. **防抖和节流**
7. 构建优化
   1. 打包公共代码 使用CommonsChunkPlugin插件 参考
   2. **动态导入和按需加载**
   3. **剔除无用代码** tree shaking 主要插件 uglifyjs purifyCSS
   4. 长缓存优化（忽略）

## vue 相关

### vue 的优势

1. 轻量级框架
2. 双向数据绑定（即响应式数据绑定）  -- 最大优点
3. 组件化开发
4. 虚拟dom 节省了大量性能 比react快

### mvvm 和 mvc 区别

1. mvc和mvvm都是一种设计思想。 主要就是mvc中Controller演变成mvvm中的viewModel。 mvvm主要解决了mvc中大量DOM操作使页面渲染性能降低，加载速度变慢的问题 。
2. MVVM与MVC最大的区别就是：它**实现了View和Model的自动同步**：当Model的属性改变时，我们不用再自己手动操作Dom元素来改变View的显示，它会自动变化。 （数据变化页面直接跟着变化）
3. 整体看来，MVVM比MVC精简很多，我们不用再用选择器频繁地操作DOM。

### vue 双向绑定的原理

采用数据劫持和发布者-订阅者模式
数据劫持是通过 Object.defineProperty实现的，defineProperty可以控制对象属性的一些特有操作比如读写，是否可枚举等。其中最重要的就是get和set方法,可以通过defineProperty重写get和set方法来自定义对象属性的读取和设置。

```js
Object.defineProperty(Book, 'name', {
  set: function (value) {
    name = value;
    console.log('你取了一个书名叫做' + value);
  },
  get: function () {
    return '《' + name + '》'
  }
})
```

#### 具体的实现（了解）
1. 实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。
2. 实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。
3. 实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器

[参考](https://www.cnblogs.com/chenhuichao/p/10818396.html)

### vue2 和 vue3 双向绑定原理的区别 ：proxy

vue2如上
vue3采用的是proxy来实现双向绑定的

#### 为啥vue3要改用proxy

object.defineProperty的缺点
1. 因为只能监听对象的属性，所以需要深度遍历，监听需要一次性递归 (遍历每个对象的每个属性，如果对象嵌套很深的话，需要使用递归调用。
2. 无法监听新增属性/删除属性(Vue.set Vue.delete，未在 data 中定义的属性会报 undefined)
3. 无法原生监听数组，需要特殊处理（比如直接根据下标来修改值不能实时响应）

`let proxy = new Proxy(target,handler)`
proxy支持13种拦截方式，相比老版更加丰富

Reflect是ES6为了操作对象而新增的API，个人理解为之前Object的优化，并完美支持proxy

#### proxy的缺点
proxy 无法兼容所有浏览器，无法进行polyfill

### data 为啥是函数

因为**组件是可以复用**的, JS里对象是**引用**关系, 如果组件data是一个对象, 那么在子组件中的data属性值会**互相污染**, 产生副作用。所以一个组件的data选项必须是一个函数, 这样才让每个实例可以维护一份被返回对象的独立拷贝。

### data computed watch 的依赖关系

computed计算属性显然依赖于data中的属性

### 为啥 v-for 和 v-if 不建议一起用

当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。这意味着 v-if 将分别重复运行于 每个 v-for 循环中，即先运行 v-for 的循环，然后在每一个 v-for 的循环中，再进行 v-if 的条件对比，会造成性能问题，影响速度。

建议使用计算属性替代

### 插槽（匿名，具名，作用域）及用法

#### 匿名插槽

`<slot />`

#### 具名插槽  一一对应即可

子组件
``` vue
<slot name="header"></slot>
<slot name="footer"></slot>
```
父组件
```vue
<h1 slot="header">h1</h1>
<h1 slot="footer">h1</h1>
```

#### 作用域插槽 - 带数据的插槽 可用slot-scope获取数据

- 子组件中
`<slot  :data="data"></slot>` 
- 父组件
``` vue
<template slot-scope="user">
  <div class="tmpl">
    <span v-for="item in user.data">{{item}}</span>
  </div>
</template>
```

### vue 的生命周期

1. beforeCreate 刚创建实例，没有数据和计算属性等 可以访问到 $el 和 $options
2. created 实例创建完，可以访问data和methods，$el上的属性还不存在
3. beforeMount 实例已挂载到dom上，但是dom还没更新
4. mounted 实例已挂在到dom，dom已更新，`$el`属性可见，用`this.$el`可以访问
5. beforeUpdate data已更新，dom未更新
6. updated dom和data都更新完毕
7. beforeDestory 实例销毁前，此时事件监听和watcher都已移除，但是dom还没移除
8. destoryed 实例销毁后，事件监听和watcher和dom都移除
9. activated  keep-alive激活时调用
10. deactivated  keep-alive停用时调用
11. errorCaptured 捕获子组件的错误 会向上冒泡 可以在此处进行错误处理

deforeDestory注意点
自定义的全局事件要在退出该页面钱进行解绑
```js
mounted () {
  window.addEventListener('scroll', this.handleScroll)
},
beforeDestroy () {
  window.removeEventListener('scroll', this.handleScroll)
}
```

### 组件之间的传值
TODO:待丰富

1. 父 -> 子  props
2. 子 -> 父  events($emits)
3. $parent / $children 两种都是直接得到组件实例，使用后可以直接调用组件的方法或访问数据。
4. 总线机制bus event bus 
要创建一个公共bus.js 然后在其他组件中引入 作为中间传达的工具
5. vuex
6. $attrs / $listeners
7. 祖 -> 孙 provide / inject

### 封装过的 vue 组件

### vue 的 template 是怎么编译的
TODO:
1. vue template模板编译的过程经过parse()生成ast(抽象语法树),optimize对静态节点优化，generate()生成render字符串
2. 之后调用new Watcher()函数，用来监听数据的变化，render 函数就是数据监听的回调所调用的，其结果便是重新生成 vnode。
3. 当这个 render 函数字符串在第一次 mount、或者绑定的数据更新的时候，都会被调用，生成 Vnode。
4. 如果是数据的更新，那么 Vnode 会与数据改变之前的 Vnode 做 diff，对内容做改动之后，就会更新到我们真正的 DOM

### vue 的两种路由模式 hash 和 history

#### hash模式

1. hash模式是url后面带有#的情况，#后面的值不会包含在http请求，所有改变hash的值不会引起页面的重新加载，不会像服务器重新发起请求

hash原理： onhashchange事件，页面每次hash值得变化都会触发hashchange事件

会创建hashHistory对象，会被浏览器记录下来，在访问不同的路由会发生两种事件：hashHistory.push()：将新的路由添加到浏览器访问的历史栈顶，
hashHistory.replace()替换到当前栈

#### history模式

1. url不带#参数，看起来更美观
2. history模式依赖于前后端交互，即url修改就会请求后端url，如果后端没配置对应的/user/id的路由处理，就会返回404报错
3. history原理：onpopstate事件，当浏览器跳转到新的状态时会触发popstate事件

### $route 和$router 的区别

$route 是"路由信息对象"，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数 (信息)
$router 是"路由实例(VueRouter)"对象，相当于一个全局的路由器对象,包括了路由的跳转方法，钩子函数等。如history对象，this.$router.push（）返回上一个history也是使用$router.go(-1)  (实例)

### 动态路由怎么获取传递的动态参数

场景：User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染
动态路径参数，使用“冒号”开头，一个路径参数，使用冒号标记，当匹配
到一个路由时，参数会被设置到 this.$router.params 中，并且可以在每个组件
中使用。
`{ path: '/user/:id', component: User }`
在匹配到该路由之后，动态参数会被设置到this.$route.params
```vue
template: '<div>User {{ $route.params.id }}</div>'
```
也可以是多个参数
`/user/:username/post/:post_id` 与路由一一对应

#### params和query的区别是什么

1. query 要用 path 来引入，params 需要用 name 来引入
2. 接收参数时，分别是`this.$route.query.name`  和 `this.$route.params.name` (注意：是`$route`而不是`$router`)
3. query 更加类似于我们 ajax 中 get 传参，params 则类似于 post，前者在浏览器的地址中显示，params 不显示
4. params 传值一刷新就没了，query 传值刷新还存在（因为是保存在地址栏中的）
   
### 路由传值的实现方式
共2种 params 和 query
#### params

```js
// 这边的name是给path取的别名，name最重要的一点就是配合params进行路由的参数传递
const routes = [
  {
    path: '/login',
    component: Login
  },
  {
    path: '/home',
    name: 'home',
    component: Home
  }
]

login() {
  this.$router.push({
    name: 'home',
    params: { username: this.username }
  })
}
```

#### query

```js
data:{
  username: ''
},
login() {
  ...
  this.$router.push({
    path: '/home',
    query: { username: this.username },
  })
}
```

### vue-router 的钩子函数 路由守卫
TODO:背
1. 全局钩子
   1. beforeEach  `router.beforeEach(to,from,next)`
   2. afterEach
   3. beforeResolve
2. 路由独享钩子
   1. beforeEnter  写在路由配置中，访问到这个路径会触发这个钩子函数
  ```js
  routes: [
    {
      path:'/foo',
      componenet: Foo,
      beforeEnter: (to,from,next) => {}
    }
  ]
  ```
3. 组件内钩子
   1. beforeRouterEnter 写在组件中，即将渲染组件的时候触发 不能访问this
   2. beforeRouterUpdate
   3. beforeRouterLeave
   ```js
   // 写在vue组件中
    beforeRouterLeave(to,from,next) {}
   ```

### vue 的 nextTick

nextTick: 将回调推迟到下一个 DOM 更新周期之后执行 
该钩子函数执行时所有的DOM挂载和渲染都已完成
#### 应用场景
1. 在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中
2. 在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中

### mixin 的用法

mixin 是用来分发 vue 组件中的可复用功能，可包含任意组件选项，
#### 特点
1. 在被其他组件引入后，mixin中的方法和属性也就并入到该组件中
2. 数据对象在内部会进行递归合并，并在发生冲突时以**组件数据优先**
3. 同名钩子函数会被合并为一个数组，都被调用，**mixin的钩子先执行**
4. 也可以全局注入，不过会影响后面的所有vue实例，不建议

实战举例： e-charts的resize.js

### 虚拟 dom 的理解及其优点

虚拟DOM本质上是**JavaScript对象**,是对真实DOM的抽象 状态变更时，用对象记录新树和旧树的差异
最后把差异更新到真正的dom中

多次渲染DOM是很消耗前端性能的，所以减少dom的操作成为了优化前端性能的必要手段

#### 优点
1. 保证性能下限 大幅度减少了dom的操作，减少了重绘和回流的次数，提高了性能
2. 无需手动操作DOM virtualDOM的diff和patch都是在一次更新中自动进行的，无需手动操作
3. 跨平台 本质是js对象，dom是与平台强相关的，js对象可以更方便的跨平台操作

### vue 首屏加载优化方案

1. 使用cdn加载第三方库
2. 图片资源压缩（精灵图）和使用图片懒加载（虚拟列表可以讲讲）
3. vue-router路由懒加载
4. gzip压缩 webpack中使用compression-webpack-plugin插件
5. 移除 编译文件中的map文件 `productionSourceMap: false`
6. 代码层面优化 
   1. 合理使用v-if和v-show
   2. 记得及时销毁定时器 更多的参考上方前端性能优化

### vue 中 data 数组的方法哪些不可以触发视图更新？不行的话怎么解决
1. 索引设置元素   `this.array[index] = newValue`
   1. 解决方式 `this.$set(this.array,index,newValue)` 或者 `this.array.splice(index,1,newValue)`
2. 直接修改数组长度 `this.array.length = newLength`
   1. 解决方式   `this.array.splice(newLength)`

### vue 底层是怎么实现对数组的监听的

在将数组处理成响应式数据后，如果使用数组原始方法改变数组时，数组值会发生变化，但是并不会触发数组的setter来通知所有依赖该数组的地方进行更新，为此，vue通过**重写数组的某些方法**来监听数组变化，重写后的方法中会手动触发通知该数组的所有依赖进行更新。

重写的数组方法：
push pop shift unshift splice sort reverse

### vue 踩过的坑

1. 给data中的对象直接添加属性并赋值 无效果
解决方法：Vue.set(object, attribute, value)新增的属性也是响应式的
2. 在created中操作dom报错，无法获取到dom
解决方法：Vue.nextTick()

## 网络相关

### http状态码

1. 常见分类
1xx - 服务器收到请求。
2xx - 请求成功，如 200。
3xx - 重定向，如 302。
4xx - 客户端错误，如 404。
5xx - 服务端错误，如 500。

2. 常见状态码
200 - 成功。
301 - 永久重定向（配合 location，浏览器自动处理）。
302 - 临时重定向（配合 location，浏览器自动处理）。
304 - 资源未被修改。
403 - 没权限。
404 - 资源未找到。
500 - 服务器错误。
504 - 网关超时

### http执行机制

### 三次握手和四次挥手

第1次握手：客户端发送一个带有SYN（synchronize）标志的数据包给服务端；
第2次握手：服务端接收成功后，回传一个带有SYN/ACK标志的数据包传递确认信息，表示我收到了；
第3次握手：客户端再回传一个带有ACK标志的数据包，表示我知道了，握手结束。
其中：SYN标志位数置1，表示建立TCP连接；ACK标志表示验证字段

第1次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入FIN_WAIT_1状态；
第2次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务端进入CLOSE_WAIT状态；
第3次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入LAST_ACK状态；
第4次挥手：客户端收到FIN后，客户端t进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，服务端进入CLOSED状态，完成四次挥手

### 从 url 被输入到请求返回发生了什么

1. 输入 URL 后解析出协议、主机、端口、路径等信息，并构造一个 HTTP 请求。
   1. 强缓存
   2. 协商缓存
2. DNS 域名解析
3. TCP 连接
> 总是要问：为什么需要三次握手，两次不行吗？其实这是由 TCP 的自身特点可靠传输决定的。客户端和服务端要进行可靠传输，那么就需要确认双方的接收和发送能力。第一次握手可以确认客服端的发送能力，第二次握手，确认了服务端的发送能力和接收能力，所以第三次握手才可以确认客户端的接收能力。不然容易出现丢包的现象。
4. HTTP 请求
5. 服务器处理请求并返回 HTTP 报文
6. 浏览器渲染页面（important）
   1. 先将HTML加载到浏览器的内部。
   2. 从上往下开始解析HTML。
   3. 当解析到引入的外部CSS文件时，另一个线程开始加载CSS文件，HTML继续解析。
   4. 浏览器解析DOM文档时，会将DOM文档解析成一棵树结构–DOM Tree，用来更清晰的显示出标签之间的层级关系。
   5. HTML解析完毕之后，等待CSS解析。
   6. CSS文件会被解析成CSS规则树(CSSOM Tree)，解析完毕之后会将每个节点的样式附加到DOM Tree形成布局树，最后再化为Render Tree （渲染树）
   7. 在渲染树(Reader Tree)上运行布局(Layout) 以计算每个节点的几何体，然后将每个节点绘制 到屏幕上
7. 断开 TCP 连接

### 前端缓存的几种缓存方式

HTTP缓存和浏览器缓存
http缓存包括 强缓存和协商缓存 如上面
浏览器缓存分为本地存储 即cookie localStorage和sessionStorage 如上 

## webpack 相关

## typescript 和 vue3 相关

## uniapp 相关

## 性能优化相关

## 其他

### 遇到最困难的问题是啥 怎么解决

[参考 1](https://juejin.cn/post/7031322059414175774)

[参考 2](https://juejin.cn/post/7061588533214969892)
