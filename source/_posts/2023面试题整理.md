---
title: 2023面试题整理
date: 2023-02-21 16:31:32
tags: 面试题
categories:
- 面试题
---

## js 手写题

### 手写深拷贝

```js
function deepClone(obj = {}) {
  // 是null或者不是对象和数组 直接返回
  if (typeof obj !== "object" || obj == null) {
    return obj;
  }
  let result;
  if (obj instanceof Array) {
    result = [];
  } else {
    result = {};
  }
  for (let item in obj) {
    if (obj.hasOwnProperty(item)) {
      // 保证key不是原型的属性
      result[item] = deepClone(obj[item]);
    }
  }
  return result;
}

// 方法2
function deepClone(obj) {
    // 1 判断是否是非应用类型或者null
    if (typeof obj !== 'object' || obj == null) return obj
    // 2 创建一个容器
    let cloneObj = new obj.constructor()
    // 3 拿到对象的keys，给容器赋值
    Object.keys(obj).forEach(v => cloneObj[v] = deepClone(obj[v]))
    // 4 返回容器
    return cloneObj
}

```

### 手写 call apply bind 函数

```js
function call() {}
```

### 手写一个简易的jquery，考虑插件和扩展性

```js
class jQuery {
  constructor(selector) {
    const result = document.querySelectorAll(Selector);
    const length = result.length;
    for(let i=0;i<length;i++) {
      this[i] = result[i]
    }
    this.length = length
  }
  get(index) {
    return this[index]
  }
  each(fn) {
    for(let i=0;i<this.length;i++) {
      const elem = this[i];
      fn(elem)
    }
  }
  on(type,fn) {
    return this.each(elem => {
      elem.addEventListener(type,fn,false)
    })
  }
}

// 插件
jQuery.prototype.dialog = function(info) {
  alert(info)
}

// 造轮子
class MyJquery extends jQuery {
  constructor(selector) {
    super(selector);
  }
}
```

### 手写 new 函数

### 事件总线 | 发布订阅模式 event bus （EventMitter）

### 柯里化

### instanceof

### 数组扁平化

### 节流

### 防抖

### 手写 reduce

### 实现简单的 promise

### 手写 deep clone

### 图片懒加载

### 异步控制并发数

### es5 和 es6 继承

### 数组排序

### 数组去重

### 获取 url 参数

## html&css 相关

### html语义化标签怎么理解

- 让人更容易读懂
- 让搜索引擎更容易读懂，有利于爬虫爬取更多的有效信息
- 没有css情况下，也能呈现很好的内容结构

### script 标签的 defer 和 async 区别

script: 会阻碍html解析，只有下载好并执行完脚本才会继续解析html
async script: 解析html过程中会进行脚本的异步下载，下载成功立马执行，有可能阻断html的解析 **异步下载，立即执行**
defer script: 完全不阻碍html的解析，解析完成后再按照顺序执行脚本 **异步下载，解析完执行**

### 盒模型

两种盒模型：标准盒模型、IE盒模型
相同点：都是由 content + padding + border + margin构成
不同点：盒子内容的宽/高度
标准盒模型： 只包含content    box-sizin: content-box
IE盒模型： content + padding + border box-sizing: border-box

### 选择器及其优先级

!important > style(内联) > id > class

### reflow（重排/回流）和 repaint（重绘）理解

#### 重排/回流：
**第一次确定节点的大小和位置，称为布局，之后针对节点大小，位置改变重新计算称之为回流**
元素的**几何信息**被影响导致浏览器需要**重新计算**元素在视口内的几何属性（位置和尺寸）

#### 引发回流的几种情况
1. DOM结构发生变改变，如添加新的节点或者移除节点
2. 改变布局，如修改了width height padding font-size等值。
3. 改变窗口 resize,修改了窗口的尺寸。
4. 调用 getComputedStyle方法获取尺寸、位置信息。

#### 重绘：
**第一次渲染内容称之为绘制，之后重新渲染称之为重绘**
通过构造渲染树和重排（回流）阶段，我们知道了可见节点的样式和具体的几何信息，接下来将渲染树的每个节点转换为屏幕上的**实际像素**的阶段

#### 引发重绘的几种情况
修改背景色、文字颜色、边框颜色、样式等。

### 如何减少重排和重绘

- 最小化重绘和重排，修改样式尽量集中一次性修改
- 尽量避免频繁的操作DOM
- 批量操作DOM 比如读取某元素 offsetWidth 属性存到一个临时变量，再去使用，而不是频繁使用这个计算属性；又比如利用 `document.createDocumentFragment()` 来添加要被添加的节点，处理完之后再插入到实际 DOM 中
- 尽量避免通过 `getComputedStyle` 获取尺寸位置信息
- 使用 **absolute** 或 **fixed** 使元素脱离文档流，这在制作复杂的动画时对性能的影响比较明显
- 开启 GPU 加速，利用 css 属性 transform 、will-change 等，比如改变元素位置，我们使用 translate 会比使用绝对定位改变其 left 、top 等来的高效，因为它不会触发重排或重绘，transform 使浏览器为元素创建⼀个 GPU 图层，这使得动画元素在一个独立的层中进行渲染(每个合成层都是单独渲染的)。当元素的内容没有发生改变，就没有必要进行重绘

[参考](https://juejin.cn/post/6844903779700047885)

### BFC 的理解

block format context: 块级格式上下文

### 实现两栏布局（左侧固定和右侧自适应） 5 种

### 实现圣杯布局和双飞翼布局（三分栏）

### 水平垂直居中的实现

### flex：1 的含义

flex-grow: 1 ：该属性默认为 0 ，如果存在剩余空间，元素也不放大。设置为 1  代表会放大。
flex-shrink: 1 ：该属性默认为 1 ，如果空间不足，元素缩小。
flex-basis: 0% ：该属性定义在分配多余空间之前，元素占据的主轴空间。浏览器就是根据这个属性来计算是否有多余空间的。默认值为 auto ，即项目本身大小。设置为 0%  之后，因为有 flex-grow  和 flex-shrink  的设置会自动放大或缩小。在做两栏布局时，如果右边的自适应元素 flex-basis  设为 auto  的话，其本身大小将会是 0 .

### line-height 如何继承

## js 相关

### 值类型和引用类型的区别

值类型的变量直接存储数据（**栈**上），而引用类型的变量持有的是数据的引用（地址），数据存储在数据**堆**中。

引用类型：当**声明**一个类时，只在**栈**中分配一小片内存用于容纳一个地址，而此时并没有为其分配堆上的内存空间。当使用 **new** 创建一个类的实例时，分配**堆**上的空间，并把堆上空间的地址保存到栈上分配的小片空间中。


### typeof 能判断哪些类型

所有类型：undefined null(特殊引用类型，指向空地址) string number boolean symbol function(特殊引用类型)

1. 识别所有值类型
2. 识别函数 返回 'function'
3. 判断是否是引用类型

注意： typeof null | [1,2]  => "object"

### === 和 == 的区别
== 只要求值相等即可 即经过类型转换为同一类型后值相等即可
=== 不仅值相等 类型也要相同

使用过程中，除了 == null 之外，其他一律用 === 
if(obj.a == null) 等价于 if(obj.a === null || obj.a === undefined)

truly变量： !!a === true的变量
falsely变量  !!a === false的变量 ( 0 NaN "" null undefined false )

逻辑判断：
10 && 0 前面是truly值，&&直接返回后面的值
"" || 'abc' 前面是falsely值， ||直接返回后面的值

### 为啥 0.1+0.2 ！== 0.3

是由于浮点数运算的精度问题（精度是有限的）导致等式左右的结果不严格相等
浮点数转成二进制是无限循环的，所以计算机中只能存储一个近似值

正确的比较方法 是使用js提供的最小精度值 Number.EPSILON
`Math.abs(0.1+0.2-0.3) <= Number.EPSILON`

### 原型及原型链

原型：
每个class都有显式原型prototype
每个class实例化后的对象都有隐式原型__proto__
实例的隐式原型指向对应class的显式原型
class类具有定义的属性和方法，也有显式原型prototype。而将这个class类实例化后就有了隐式原型__proto__，即shilihua.proto === Student.proptotype

原型链：
首先，每个对象在初始化的时候都会被添加上__proto__属性，指向该对象的原型对象，同时在js中万物皆对象，所以该对象的原型对象也有__proto__属性指向它的原型对象，这样一直指下去就会形成一个原型形成的链，简称原型链。

### 如何判断一个变量是不是数组

param instanceof Array (return true/false)

xialuo instanceof Student  (true)

### class的原型本质，怎么理解

TODO:原型和原型链的图示

class可以理解为一个模板，本质就是一个函数，通过constructor构造方法来构造一些属性和方法，然后通过new关键字来实例化这个类
继承： 子类在自身的constructor方法中用super关键字调用父类的constuctor方法

### js的几种继承方式

TODO:

- 原型继承：

优点：通过原型继承多个引用类型的属性和方法

缺点：Sub原型变成了Super的实例，如果Super的实例某个属性是引用值，该引用值就会被应用到所有Sub创建的实例中去，会有污染问题。

- 盗用构造函数

优点：每个实例都会有自己的a属性，哪怕是引用值也不会被污染

缺点：Super构造函数中的方法在每个实例上都要创建一遍（除非该方法声明提到全局）

- 组合继承

优点： 集合了原型继承和盗用构造函数继承的优点

缺点：存在效率问题，Super始终会被调用两次

- 原型式继承

优点：对一个对象进行浅克隆创建另一个对象，同时继承该对象的原型属性

缺点：由于是浅克隆，所以实例共享的对象属性如果是引用值，会受污染

- 寄生式继承

优点：根据一个对象克隆创建另一个对象，并增强对象

缺点：同【盗用构造函数继承】方法在每个实例上都要创建一遍

- 寄生式组合继承

优点：集合了【原型式继承】和【盗用构造函数继承】的优点，效率比【组合继承】更高。

### 作用域和作用域链

作用域（scope） ：当前的**执行上下文**，作用域就是一个独立的地盘，让变量不会外泄、暴露出去。作用域最大的用处就是**隔离变量**，不同作用域下的同名变量不会有冲突。

- 全局作用域 （最外层定义的变量和函数，未定义并直接赋值的变量-变量提升，window对象的属性）
- 函数作用域 （函数内部定义的变量）
- 块级作用域 （let const声明的变量）

作用域链

- 自由变量 当前作用域中没有定义的变量，称为自由变量。
- 作用域链  访问变量时，自己的作用域中没有，一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃，这种一层一层的关系，就是作用域链
- 作用域与执行上下文的区别
  - 解释阶段（作用域规则确定）
  - 执行阶段（执行上下文）

执行上下文在运行时确定（this的指向问题），随时可能改变，作用域（变量的值）在定义时就确定，并且不会改变。


### 执行上下文

是js代码执行的一个环境，存放了代码执行所需的变量，变量查找的作用域链规则以及this指向等

### 闭包

1. 有权访问其他函数作用域中变量得函数

2. 闭包是指那些能够访问自由变量的函数。 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。 闭包 = 函数 + 函数能够访问的自由变量

所有（闭包）自由变量的查找 是在函数定义的地方，向上级作用域查找 不是在执行的地方

#### 怎么创建闭包

在一个函数内部创建另一个函数

#### 闭包的作用

可以阻止变量被回收 

#### 闭包的缺点

比普通函数更加占用内存，可能造成内存泄漏，不会被垃圾回收机制回收

#### 闭包的实际应用场景

循环绑定监听事件,给标签循环添加监听事件 
解决方式：1. 立即执行函数 2. es6声明 let const等（如下）
```js
let a,i
for(i=0;i<10;i++) {
  // 这里面的i都是10
}
// 正确写法
let a
for(let i=0;i<10;i++) {
  // 这里都是块级作用域
}
```

### 垃圾回收机制

任务：找到**哪些被分配的内存确实已经不再需要了**

1. 引用计数垃圾收集
理解为 对象有没有其他对象引用它，如果没有就标记为**零引用**，对象将被垃圾回收机制回收
限制：循环引用的风险

2. 标记-清除算法
理解为 对象是否可以获得 假定设置一个root对象，垃圾回收器会定期从根开始找所有从它开始引用的对象，如果从全局对象无法获取的对象则会被垃圾回收器回收
限制: 那些无法从根对象查询到的对象都将被清除（一般没问题）


### this 的用法及含义

**this取什么值是在函数被执行的时候确定的，不是在定义的时候**

this的指向问题
1. 作为普通函数 window
2. 使用call bind apply （call可直接换this指向 bind是有返回值 返回值再调用）
3. 作为对象方法被调用 指代的就是这个对象本身
4. 在class方法中调用 当前实例本身 setTimeout注意
5. 箭头函数  `()=>{this}` 和上级作用域的值一致

### web 存储

1. cookie
   1. 特点
      1. 本身用于浏览器和server通讯
      2. 可用`document.cookie = 'xxx'`来修改
   2. 缺点
      1. 存储大小限制为4KB
      2. http请求需要发送到服务端，增加请求数量
      3. 只能用document.cookie修改
2. localStorage 和 sessionStorage
   1. 特点
      1. 最大可存储 5MB
      2. api 简单易用，setItem getItem
      3. 不会跟随 http 请求发送给服务端
   2. 区别
      1. localStorage 会永久存储，除非手动删除
      2. sessionStorage 数据只存在当前会话，浏览器关闭则清空
      3. 一般用 localStorage 较多

### http 缓存（强制缓存 | 协商缓存）

#### 为什么需要缓存？ 

网络请求相比于 CPU 的计算和页面渲染是非常非常慢的。

#### http缓存机制
http 缓存机制主要在http相应头中设定，响应头中相关字段为 Expires,Cache-Control,Last-Modified,If-Modified-Since,Etag 等
1. Expires
2. Cache-Control
   1. max-age：用来设置资源（representations）可以被缓存多长时间，单位为秒
   2. s-maxage：和max-age是一样的，不过它只针对代理服务器缓存而言；
   3. public：指示响应可被任何缓存区缓存；
   4. private：只能针对个人用户，而不能被代理服务器缓存；
   5. no-cache：强制客户端直接向服务器发送请求,也就是说每次请求都必须向服务器发送。服务器接收到请求，然后判断资源是否变更，是则返回新内容，否则返回304，未变更。这个很容易让人产生误解，使人误以为是响应不被缓存。实际上Cache-Control: no-cache是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。
   6. no-store：禁止一切缓存（这个才是响应不被缓存的意思）。

#### 强制缓存
过程：
1. 初次请求，服务器返回资源和cache-control
2. 再次请求，本地缓存直接返回资源

cache-control

#### 协商缓存（对比缓存）
- 服务端缓存策略。
- 服务端判断客户端资源，是否和服务端资源一样。
- 一致则返回 304，否则返回 200 和最新的资源。
过程：
1. 初次请求，服务器端返回资源和资源标识
2. 再次请求时带着资源标识，服务器端返回304，或返回资源（200）和新的资源标识

资源标识：保存在Response Headers中
1. Last-Modified： 资源的最后修改时间
2. Etag： 资源的唯一标识

##### Last-modified  If-Modified-Since
服务端拿到 if-Modified-Since 之后拿这个时间去和服务端资源最后修改时间做比较，如果一致则返回 304 ，不一致（也就是资源已经更新了）就返回 200 和新的资源及新的 Last-Modified。
##### Etag  If-None-Match
其实 Etag 和 Last-Modified 一样的，只不过 Etag 是服务端对资源按照一定方式（比如 contenthash）计算出来的唯一标识，就像人类指纹一样，通过 **If-None-match**（就是Etag的值） 传给客户端之后，客户端再传过来时候，服务端会将其与现在的资源计算出来的唯一标识做比较，一致则返回 304，不一致就返回 200 和新的资源及新的 Etag。

#### 总结
Etag的优先级比last-modified高

last-modified的不足：
1. 只能精确到秒级，如果一个文件一秒内多次修改，不能准确标注文件的修改时间
2. 如果一个文件定期生成且内容没有变化，last-modified也会改变，导致无法使用缓存

### 异步

异步就是当某一代码执行异步过程调用发出后，这段代码不会立刻得到返回结果，而是在异步调用发出之后，一般通过回调函数处理这个调用之后拿到结果。异步调用发出后，**不会影响阻塞**后面的代码执行

1. 最开始实现异步都是采用**回调函数**实现的，但是有个缺点：回调地狱
2. 为了解决回调地狱的问题，ES6提出了Promise的方式 （Generator配合yield方式）
3. ES7又提出新的异步解决方案 async/await async是Generator函数的语法糖，优点是使异步逻辑的代码跟同步一样容易理解

### promise

TODO:实现一遍Promise A+规范

### event loop

异步任务不进入主线程，而是进入**任务队列**，当主线程中的任务执行完毕，就从任务队列中取出任务放进主线程中来进行执行。由于主线程不断重复的获得任务、执行任务、再获取再执行，所以这种机制被叫做事件循环。

1. event loop过程1
   1. 同步代码，一行一行放在call Stack（执行栈）执行
   2. 遇到异步，会先记录下并交给其他线程处理，等待时机（定时，网络请求）
   3. 时机到了，就会移动到callback queue
2. event loop过程2
   1. 如果call stack为空（同步代码执行完），event loop开始工作
   2. 轮训查找callback queue，如果有则移动到call stack
      1. 优先检查微任务队列是否有任务，没有的话再去宏任务队列检查
   3. 然后继续轮训查找

另一种说法：
1. 执行一个宏任务（栈中没有就从事件队列中获取）
2. 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
4. 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
5. 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）

总结：
1. tasks 按序执行，浏览器会在 tasks 之间执行渲染。
2. microtasks 按序执行，在下面情况时执行：
   1. 在每个回调之后，只要没有其它代码正在运行。
   2. 在每个 task 的末尾

### 宏任务微任务

异步任务队列不只一个，根据任务种类分为微任务队列(micro task/ Task)和宏任务队列(macro task/Jobs)

宏任务 -（当前微任务） - 渲染 - 宏任务 。。。

**微任务比宏任务执行时间要早**

常见宏任务：
1. setTimeout
2. setInterval
3. setImmediate(Node)
4. 点击事件或键盘事件 i/o事件
5. Ajax
6. script整体代码段
7. promise里面的代码

常见微任务
1. **promise.then**,**await**（与then类似）,promise.catch
2. object.observe
3. new MutationObserver(浏览器环境)
4. process.nextTick(node)

注意：async函数在await之前的代码都是**同步**执行的，可以理解为await之前的代码属于new Promise传入的代码，**await之后的代码都是在Promise.then中的回调**

### 柯里化

柯里化就是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术

```js
function sum(a,b,c) {
  return a+ b + c
}
// 柯里化之后
function sum(a) {
  return function(b) {
    return function(c) {
      return a + b + c
    }
  }
}
// 调用时
sum(1)(2)(3)
```

#### 柯里化的好处
我们处理函数时，希望函数功能尽可能单一

#### 自动柯里化
(个人感觉不重要，理解什么是柯里化即可)
```js
function myCurried(fn) {
  return function curry(...args1) {
    if (args1.length >= fn.length) {
      return fn.call(null, ...args1)
    } else {
      return function (...args2) {
        return curry.apply(null, [...args1, ...args2])
      }
    }
  }
}

function sum(a, b, c, d, e) {
  return a + b + c + d + e
}
let resFunc = myCurried(sum)
console.log(resFunc(1,3,4)(1)(23))
//解析:
//1、这里的fn.length获取的是函数传入参数的长度
//2、这里使用递归的思想
```

### 箭头函数的优缺点

#### 优点
1. 简写了函数
2. **改变this的指向为当前外部对象**

#### 缺点
1. 没有arguments参数
2. 无法通过apply bind call来改变this的指向

#### 不能用于哪些场景
1. 不能用于对象方法
2. 不能用于对象原型
3. 不能用于构造函数
```js
const obj = {
    a:'a'
    getA: () => {
        return this.a
    }
}
console.log( obj.getA() ) //undefined
```


### 前端性能优化的措施

[参考](http://www.pczh.cn/news/22013.html)
#### 代码层面
1. 减少请求数量
   1. **图片处理**
      1. 雪碧图
      2. Base64
      3. 使用字体图标
   2. 减少重定向
   3. **使用缓存**
   4. **不使用CSS @import**
   5. 避免使用空的src和href
2. 减小资源大小
   1. **压缩 html css js 和图片均可压缩**
   2. **使用webp格式的图片**
   3. **开启gzip**（www服务器中安装的功能，用来压缩网页内容后传输到来访的电脑浏览器中）
3. 优化网络连接
   1. **使用CDN**
   2. 使用DNS预解析 （DNS Prefetch，即DNS预解析就是根据浏览器定义的规则，提前解析之后可能会用到的域名，使解析结果缓存到系统缓存中，缩短DNS解析时间，来提高网站的访问速度） `<link rel="dns-prefetch" href="xxx">`
4. 优化资源加载
   1. **资源加载位置**
      1. css放在head中，先外链，再本页
      2. js放在body底部，先外链，再本页
      3. 处理页面及页面布局的js'文件放在head中，如flexible.js
      4. body中尽量不写style和script标签
   2. **资源加载时机**
      1. 异步script标签
         1. defer html解析完立即执行
         2. async 加载完成后立即执行
      2. 模块按需加载
      3. 使用资源预加载preload和资源预读取prefetch
      4. 资源懒加载和资源预加载
5. 减少重绘回流
   1. 避免使用层级较深的选择器
   2. 避免使用CSS表达式，计算频率太高
   3. **元素适当的定义高度或设置最小高度，以免动态载入内容时出现页面元素晃动**
   4. **给图片设置尺寸，不然从0到有会位移，产生回流**
   5. **能用css实现就不要用js实现**
   6. 对需要多次重绘的元素独立为render layer渲染层，设置absolute
6. DOM优化
   1. 缓存DOM `const div = document.getElementById('div')`
   2. 减少DOM深度
   3. **批量操作DOM** 比如先拼接完字符串再更新DOM
   4. **事件代理**
   5. **防抖和节流**
7. 构建优化
   1. 打包公共代码 使用CommonsChunkPlugin插件 参考
   2. **动态导入和按需加载**
   3. **剔除无用代码** tree shaking 主要插件 uglifyjs purifyCSS
   4. 长缓存优化（忽略）

## vue 相关

### vue 的优势

### mvvm 和 mvc 区别

### vue 双向绑定的原理

### vue2 和 vue3 双向绑定原理的区别 ：proxy

### data 为啥是函数

### data computed watch 的依赖关系

### 为啥 v-for 和 v-if 不建议一起用

### 插槽（匿名，具名，作用域）及用法

### vue 的生命周期

### 组件之间的传值

### 封装的 vue 组件

### vue 的 template 是怎么编译的

### vue 的两种路由模式 hash 和 history

### $route 和$router 的区别

### 动态路由怎么获取传递的动态参数

### vue-router 的钩子函数

### 路由传值的方式

### vue 中 data 数组的方法哪些不可以触发视图更新？不行的话怎么解决

### vue 首屏加载优化方案

### vue 的 nextTick

### mixin 的用法

### 虚拟 dom 的理解及其优点

### vue 底层是怎么实现对数组的监听的

## 网络相关

### http执行机制

### 从 url 被输入到请求返回发生了什么

1. 输入 URL 后解析出协议、主机、端口、路径等信息，并构造一个 HTTP 请求。
   1. 强缓存
   2. 协商缓存
2. DNS 域名解析
3. TCP 连接
> 总是要问：为什么需要三次握手，两次不行吗？其实这是由 TCP 的自身特点可靠传输决定的。客户端和服务端要进行可靠传输，那么就需要确认双方的接收和发送能力。第一次握手可以确认客服端的发送能力，第二次握手，确认了服务端的发送能力和接收能力，所以第三次握手才可以确认客户端的接收能力。不然容易出现丢包的现象。
4. HTTP 请求
5. 服务器处理请求并返回 HTTP 报文
6. 浏览器渲染页面（important）
   1. 先将HTML加载到浏览器的内部。
   2. 从上往下开始解析HTML。
   3. 当解析到引入的外部CSS文件时，另一个线程开始加载CSS文件，HTML继续解析。
   4. 浏览器解析DOM文档时，会将DOM文档解析成一棵树结构–DOM Tree，用来更清晰的显示出标签之间的层级关系。
   5. HTML解析完毕之后，等待CSS解析。
   6. CSS文件会被解析成CSS规则树(CSSOM Tree)，解析完毕之后会将每个节点的样式附加到DOM Tree形成布局树，最后再化为Render Tree （渲染树）
   7. 在渲染树(Reader Tree)上运行布局(Layout) 以计算每个节点的几何体，然后将每个节点绘制 到屏幕上
7. 断开 TCP 连接

### 前端缓存的几种缓存方式

## webpack 相关

## typescript 和 vue3 相关

## uniapp 相关

## 性能优化相关

## 其他

### 遇到最困难的问题是啥 怎么解决

[参考 1](https://juejin.cn/post/7031322059414175774)

[参考 2](https://juejin.cn/post/7061588533214969892)
