---
title: 2023面试题整理
date: 2023-02-21 16:31:32
tags: 面试题
categories:
- 面试题
---
# 面试题整理

## js 手写题

### 手写深拷贝

```js
function deepClone(obj = {}) {
  // 是null或者不是对象和数组 直接返回
  if (typeof obj !== "object" || obj == null) {
    return obj;
  }
  let result;
  if (obj instanceof Array) {
    result = [];
  } else {
    result = {};
  }
  for (let item in obj) {
    if (obj.hasOwnProperty(item)) {
      // 保证key不是原型的属性
      result[item] = deepClone(obj[item]);
    }
  }
  return result;
}

// 方法2
function deepClone(obj) {
    // 1 判断是否是非应用类型或者null
    if (typeof obj !== 'object' || obj == null) return obj
    // 2 创建一个容器
    let cloneObj = new obj.constructor()
    // 3 拿到对象的keys，给容器赋值
    Object.keys(obj).forEach(v => cloneObj[v] = deepClone(obj[v]))
    // 4 返回容器
    return cloneObj
}

```

### 手写 call apply bind 函数

```js
function apply(context, args) {
  context = context || window
  args = args ? args : [];
  context.fn = this;// this是调用的函数
  const res = context.fn(...args);
  delete context.fn;
  return res
}

function call(context, ...args) {
  // 剩下的都一样
}

function bind(context, ...args) {
  context = context || window
  let fn = this 
  return function newFn(...fnArgs) {
    let res
    if(this instanceof newFn) {
      res = new fn(...args, ...fnArgs)
    }else {
      res = fn.call(context, ...args, ...fnArgs)
    }
    return res
  }
}
```

### 手写一个简易的jquery，考虑插件和扩展性

```js
class jQuery {
  constructor(selector) {
    const result = document.querySelectorAll(Selector);
    const length = result.length;
    for(let i=0;i<length;i++) {
      this[i] = result[i]
    }
    this.length = length
  }
  get(index) {
    return this[index]
  }
  each(fn) {
    for(let i=0;i<this.length;i++) {
      const elem = this[i];
      fn(elem)
    }
  }
  on(type,fn) {
    return this.each(elem => {
      elem.addEventListener(type,fn,false)
    })
  }
}

// 插件
jQuery.prototype.dialog = function(info) {
  alert(info)
}

// 造轮子
class MyJquery extends jQuery {
  constructor(selector) {
    super(selector);
  }
}
```

### 手写 new 函数

```js
function createNew(Fn, ...args) {
  const newObj = Object.create(Fn);
  const res = Fn.apply(newObj, args);
  return typeof res === "object" ? res : newObj;
}
```

```js
function newFunc(father, ...rest) {
  var result = {};
  result.__proto__ = father.prototype;
  var result2 = father.apply(result, rest);
  if (
    (typeof result2 === 'object' || typeof result2 === 'function') &&
    result2 !== null
  ) {
    return result2;
  }
  return result;
}
```

### 事件总线 | 发布订阅模式 event bus （EventMitter）

```js
// 发布订阅模式
function EventEmitter() {
  this.events = {} // 事件存放对象
  this._maxListener = 10; // 默认最大绑定函数个数
}
EventEmitter.prototype.on = EventEmitter.prototype.addListener = function(type,listener) {
  if (this.events[type]) {
    this.events[type].push(listener); // 一个事件名可以绑定函数
    if (this.events[type].length != 0 && this.events[type].length > this._maxListener) { // 绑定函数数据大于最大限定个数
      console.error(`MaxListenersExceededWarning: Possible EventEmitter memory leak detected. ${this.events[type].length} ${type} listeners added. Use emitter.setMaxListeners() to increase limit`)
    }
  } else {
    this.events[type] = [listener]; 
  }
}
EventEmitter.prototype.emit = function(type,...args) {
  this.events[type] && this.events[type].forEach((item,index) => {  // 依次执行绑定的函数(数组)
    item(...args);
  })
}
EventEmitter.prototype.once = function(type,listener) {
  const wrapper =  (...args) => { // 对once进行包裹，执行完就移除，实现只执行一次的效果
    listener(...args);
    this.removeListener(type, wrapper);
  }
  this.on(type,wrapper);
}

EventEmitter.prototype.removeListener = EventEmitter.prototype.off = function(type,listener) {
  if (this.events[type]) {
    this.events[type] = this.events[type].filter(l => l != listener); // 过滤掉需要移除的绑定函数
  } else {
    console.error('no listener is able to remove');
  }
}
EventEmitter.prototype.removeAllListeners = function(...type) {
  console.log(type)
  type.forEach(t => {
    this.events[t] = null;
  })
}

EventEmitter.prototype.setMaxListener = function(maxListener) {
  this._maxListener = maxListener; // 设置最大绑定函数个数
}
EventEmitter.prototype.listeners = function(type) {
  return this.events[type]; // 返回所有指定事件的绑定函数
}
EventEmitter.prototype.getMaxListener = function() {
  return this._maxListener; // 获取最大绑定函数个数
}
EventEmitter.prototype.listenerCount = function(type) {
  return this.events[type] ? this.events[type].length : 0; // 获取指定事件绑定的函数个数
}

module.exports = EventEmitter;
```

### 柯里化

```js
function myCurried(fn) {
  return function curry(...args1) {
    if (args1.length >= fn.length) {
      return fn.call(null, ...args1)
    } else {
      return function (...args2) {
        return curry.apply(null, [...args1, ...args2])
      }
    }
  }
}
```

### 数组去重

```js
// 1. set
function unique(arr) {
  return [...new Set(arr)];
}
// 2. 双层for循环splice去重
function unique(arr) {
  for (var i = 0; i < arr.length; i++) {
    for (var j = i + 1; j < arr.length; j++) {
      if (arr[i] == arr[j]) {
        //第一个等同于第二个，splice方法删除第二个
        arr.splice(j, 1);
        j--;
      }
    }
  }
  return arr;
}
// 3. 单层for循环加indexOf
function unique(arr) {
  let array = [];
  for(let i = 0; i< arr.length;i++) {
    if(array.indexOf(arr[i]) === -1) {
      array.push(arr[i])
    }
  }
  return array;
}
// 4. sort之后 前后不同的加入数组
function unique(arr) {
  arr = arr.sort();
  let res = [arr[0]];
  for(let i = 1;i<arr.length;i++) {
    if(arr[i] !== arr[i-1]) {
      array.push(arr[i])
    }
  }
  return res;
}
// 5. includes
// 6. map数据结构去重 把数组的每一个元素作为key存到Map中。由于Map中不会出现相同的key值，所以最终得到的就是去重后的结果
//7. filter
function unique(arr) {
  return arr.filter((item, index, array) => {
    return array.indexOf(item) === index;
  });
}
```

### instanceof

```js
function myInstanceof(target, origin) {
  if (typeof target !== "object" || target === null) return false;
  if (typeof origin !== "function")
    throw new TypeError("origin must be function");
  let proto = Object.getPrototypeOf(target); // 相当于 proto = target.__proto__;
  while (proto) {
    if (proto === origin.prototype) return true;
    proto = Object.getPrototypeOf(proto);
  }
  return false;
}
```

### 数组扁平化 
TODO:重点
```js
function flat(arr,depth = 1) {
  if(depth > 0) {
    return arr.reduce((pre,cur) => {
      return pre.concat(Array.isArray(cur) ? flat(cur,depth - 1) : cur)
    },[])
  }
  return arr.slice()
}
```

### 节流
不管点多少次 一段时间内只执行一次
```js
// 使用时间戳
function throttle(func, wait) {
  let preTime = 0;

  return function () {
    let nowTime = +new Date();
    let context = this;
    let args = arguments;

    if (nowTime - preTime > wait) {
      func.apply(context, args);
      preTime = nowTime;
    }
  };
}

// 定时器实现
function throttle(func, wait) {
  let timeout;

  return function () {
    let context = this;
    let args = arguments;

    if (!timeout) {
      // 在timeout这段时间内timer都是存在的，就不会执行func，timeout时间一过就会再次执行
      timeout = setTimeout(function () {
        timeout = null;
        func.apply(context, args);
      }, wait);
    }
  };
}
```

### 防抖
不管点多少次 点击结束后一段时间才执行
```js
function debounce(func, wait, immediate) {
  let timeout;

  return function () {
    let context = this;
    let args = arguments;
    // 如果有定时器 就清除定时器啥也不执行，没有定时器后delay秒再执行方法
    if (timeout) clearTimeout(timeout);
    if (immediate) {
      let callNow = !timeout;
      timeout = setTimeout(function () {
        timeout = null;
      }, wait);
      if (callNow) func.apply(context, args);
    } else {
      timeout = setTimeout(function () {
        func.apply(context, args);
      }, wait);
    }
  };
}
```

### 手写 reduce

```js
Array.prototype.reduce = function(cb,initialValue) {
  const arr = this;
  let total = initialValue || arr[0];
  for(let i = initialValue ? 0 : 1; i < arr.length; i++) {
    total = cb(total,arr[i],i,arr);
  }
  return total
}
```

### 图片懒加载

### 异步控制并发数

### es5 和 es6 继承
#### es5
```js
function SuperType() {
  this.prototype = true;
}

SuperType.prototype.getSuperValue = function () {
  return this.prototype;
};

function SubType() {
  this.subproperty = false;
}

SubType.prototype = new SubType();

SubType.prototype.getSubValue = function () {
  return this.subproperty;
};

```

#### es6
```js
class Human {
  constructor(name) {
    this.name = name;
  }

  run() {
    console.log("RUN");
  }
}

class Man extends Human {
  constructor(name) {
    super(name);

    this.gender = "男";
  }

  fight() {
    console.log(" FIGHT");
  }
}
var User = new Man("LI Lei");
console.log(User);

```

### 数组排序 快速排序
TODO: 背
```js
function sortArray(nums) {
  quickSort(0, nums.length - 1, nums);
  return nums;
}

function quickSort(start, end, arr) {
  if (start < end) {
    const mid = sort(start, end, arr);
    quickSort(start, mid - 1, arr);
    quickSort(mid + 1, end, arr);
  }
}

function sort(start, end, arr) {
  const base = arr[start];
  let left = start;
  let right = end;
  while (left !== right) {
    while (arr[right] >= base && right > left) {
      right--;
    }
    arr[left] = arr[right];
    while (arr[left] <= base && right > left) {
      left++;
    }
    arr[right] = arr[left];
  }
  arr[left] = base;
  return left;
}
```

### 获取 url 参数
```js
function parseParam(url) {
  const paramsStr = /.+\?(.+)$/.exec(url)[1]; // 将 ? 后面的字符串取出来
  const paramsArr = paramsStr.split('&'); // 将字符串以 & 分割后存到数组中
  let paramsObj = {};
  // 将 params 存到对象中
  paramsArr.forEach(param => {
    if (/=/.test(param)) { // 处理有 value 的参数
      let [key, val] = param.split('='); // 分割 key 和 value
      val = decodeURIComponent(val); // 解码
      val = /^\d+$/.test(val) ? parseFloat(val) : val; // 判断是否转为数字
      if (paramsObj.hasOwnProperty(key)) { // 如果对象有 key，则添加一个值
        paramsObj[key] = [].concat(paramsObj[key], val);
      } else { // 如果对象没有这个 key，创建 key 并设置值
        paramsObj[key] = val;
      }
    } else { // 处理没有 value 的参数
      paramsObj[param] = true;
    }
  })
  return paramsObj;
}
```
## html&css 相关

### 转字符串类型的3种方法
1. value.toString() 参数可以控制转成多少进制 默认十进制
2. value + "" 加空字符串即可
3. String（）将数字转成字符串
4. 模板字符串

### src和href的区别

src和href都是用来引用外部的资源
`<a link href="xxx" /> <script src="xxx.js />"`
src用于替换当前元素,href用于在当前文档和引用资源之确立联系

src在浏览器中被解析到时会暂停其他资源的下载和处理，并且把该资源加载编译完成。
href在文档中进行添加时，浏览器会识别到这个文档，并命名为css文件，就会下载合并资源，同时也不会停止对当前文档的处理。

### rem em
都是相对设置的大小，rem相对于根节点html的字体大小，em是相对于父元素的字体大小

### css中link和@import的区别

1. link是XHTML标签，除了加载CSS外，还可以定义RSS等事务。 @import属于CSS范畴，只能加载CSS
2. link引用CSS在页面加载时同时加载，@import会阻塞后续css的加载。
3. link是XHTML标签，没有兼容性，@import是在CSS2.1中提出的，低版浏览器不支持
4. link支持使用Javascript控制DOM来改变样式；@import不支持。

### 伪元素和伪类区别

伪类其实就是基于普通DOM元素而产生的不同**状态**，他是DOM元素的某一特征。伪类用单冒号:表示  :link :hover :visited :first-child

伪元素能够创建在DOM树中不存在的**抽象对象**，而且这些抽象对象是能够访问到的。伪元素用双冒号::表示 ::before ::first-line

### 布局有哪些
浮动布局（float layout）
定位布局（position layout）：
弹性布局（flexbox layout）
网格布局（grid layout）

### grid布局

`display:grid`
1. grid-template-columns: 80px 90px auto 100px;//4列
2. grid-template-rows //每一个行高
3. justify-content：space-evenly
4. grid-column： 1/5 属性 是grid-column-start 和 grid-column-end 属性的简写 
5. 同理grid-row是行
6. grid-area 属性是 grid-row-start, grid-column-start, grid-row-end 以及 grid-column-end 属性的简写。 `grid-area: 1 / 2 / 5 / 6;`

### html5新特性

1. 语义化标签   header footer nav
2. 表单新属性  color date datetime number url search
3. canvas绘图 
4. 音视频 audio video
5. svg绘图  可伸缩矢量图
6. 地理定位  getCurrentPosition()获取用户位置
7. 拖放api div draggable="true"
8. websocket 全双工通信机制 实时聊天
9. webworker Web Worker可以通过加载一个脚本文件，进而创建一个独立工作的线程，在主线程之外运行。
10. webstorage localstorage sessionstorage

### 全屏滚动的实现

1. 首先 将主容器设置为占满整个屏幕，并禁止页面滚动
2. 将每个section元素设置为占满整个屏幕，并使用绝对定位将它们垂直堆叠在一起
3. 监听wheel事件 计算滚动的位置 然后window.scrollTo跳转过去
```js
document.addEventListener('wheel', function(event) {
  event.preventDefault(); // 阻止默认滚动行为
  
  var delta = event.deltaY;
  var scrollSpeed = 1000; // 滚动速度，可根据需求调整
  
  // 计算下一个要滚动到的位置
  var scrollPosition = window.pageYOffset + delta * scrollSpeed;
  
  // 滚动动画
  window.scrollTo({
    top: scrollPosition,
    behavior: 'smooth'
  });
});
```

### 什么是响应式布局

就是利用css的媒体查询功能根据不同屏幕大小 ，向下兼容设备

### 无样式内容闪烁怎么处理

一般是因为css文件的@import导致的

1. 预加载CSS和JavaScript 页面闪烁的原因往往是由于CSS和JavaScript文件的加载较慢导致页面元素的布局错乱。因此,预加载CSS和JavaScript文件成为解决页面闪烁问题的一种有效手段。可以通过将CSS文件放在<head>标签中的<link>元素中,同时将JavaScript文件放在<body>标签底部的<script>元素中,使得CSS和JavaScript文件能够优先加载
2. 使用缓存和压缩 可以减少页面加载时间,并降低页面闪烁的风险

### html语义化标签怎么理解

语义化是指根据内容的结构化（**内容**语义化），选择合适的标签（代码语义化），就是html的标签名要有意义
- 让人更容易读懂
- 让搜索引擎更容易读懂，有利于爬虫爬取更多的有效信息
- 没有css情况下，也能呈现很好的内容结构

### script 标签的 defer 和 async 区别

script: 会阻碍html解析，只有下载好并执行完脚本才会继续解析html
async script: 解析html过程中会进行脚本的异步下载，下载成功立马执行。async脚本的 下载 不会阻塞页面的解析渲染。async脚本的**执行**会阻塞页面的解析渲染 **异步下载，立即执行**
defer script: 完全不阻碍html的解析，解析完成后再按照**顺序**执行脚本 **异步下载，解析完执行**

区别在于：多个脚本异步载入时，defer会按照文档中排列的顺序按序执行，而async是谁先完成载入谁先执行，是无序的

### 常⽤的meta标签有哪些

#### 怎么用 

meta 标签是由 name 和 content 属性定义，用来描述网页文档的属性，类似给网页添加的标签

#### 常用的name有

1. charset  `<meta charset="UTF-8" >`
2. keywords  `<meta name="keywords" content="关键词" />`
3. description  `<meta name="description" content="页面描述内容" />`
4. viewport  `<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">`

### img的srcset属性的作用

响应式页面中经常用到根据屏幕密度设置不同的图片，不同屏幕密度下加载不同图片
`<img src="image-128.png"
     srcset="image-128.png 128w, image-256.png 256w, image-512.png 512w"
     sizes="(max-width: 360px) 340px, 128px" />`

### web worker

允许我们在 js 主线程之外开辟新的 Worker 线程，并将一段 js 脚本运行其中，它赋予了开发者利用 js 操作多线程的能力。

`const worker = new Worker(path, options);`

主线程与 worker 线程都是通过 postMessage 方法来发送消息，以及监听 message 事件来接收消息
```js
// main.js（主线程）
const myWorker = new Worker('/worker.js'); // 创建worker
myWorker.addEventListener('message', e => { // 接收消息
    console.log(e.data); // Greeting from Worker.js，worker线程发送的消息
});
// 这种写法也可以
// myWorker.onmessage = e => { // 接收消息
//    console.log(e.data);
// };
myWorker.postMessage('Greeting from Main.js'); // 向 worker 线程发送消息，对应 worker 线程中的 e.data
// worker.js worker线程
self.addEventListener('message', e => { // 接收到消息
    console.log(e.data); // Greeting from Main.js，主线程发送的消息
    self.postMessage('Greeting from Worker.js'); // 向主线程发送消息
});
```

### iframe 有那些优点和缺点？

iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。
优点：
- 可以直接嵌入其他网站或文档，扩展页面的功能
- 解决加载缓慢的第三方内容如图标和广告等的加载问题
- 绕过cors（跨域）限制，实现跨子域通信
- 并行加载脚本
缺点：
- iframe 会阻塞主页面的 onload 事件，减慢页面加载速度
- 第三方网站不受控制
- 没有语义，无法被一些搜索引擎索识别 不利于seo
- 会产生很多页面，不容易管理

如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值

### Canvas和SVG的区别

SVG：可缩放矢量图形
特点：
1. 不依赖分辨率
2. 支持事件处理器
3. 最适合带有大型渲染区域的应用程序（比如谷歌地图）
4. 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）

Canvas： Canvas是画布，其位置发生改变，就会重新进行绘制
特点：
1. 依赖分辨率
2. 不支持事件处理器
3. 弱的文本渲染能力
4. 能够以 .png 或 .jpg 格式保存结果图像
5. 最适合图像密集型的游戏，其中的许多对象会被频繁重绘

### 文档声明（Doctype）和`<!Doctype html>`有何作用?

文档声明是为了告诉浏览器，当前HTML文档使用什么版本的HTML来写的，这样浏览器才能按照声明的版本来正确的解析。
`<!doctype html>`是进入标准模式，不写这个就是进入混杂模式
严格模式（标准模式）： 指浏览器按照W3C标准解析代码
混杂模式： 指浏览器用自己的方式解析代码

严格模式让各个浏览器统一执行一套规范兼容模式保证了旧网站的正常运行。

### 谷歌浏览器怎么支持小于12px的文字
1. transform:scale()  推荐这种
2. zoom：50% css缩小到原来的一半 有兼容问题，会触发重排


### relative和absolute区别

position的值
absolute fixed relative static inherit

1. 定位为relative的元素脱离正常的文本流中，但其在文本流中的位置依然存在，而定位为absolute的层脱离正常文本流，但与relative的区别是其在正常流中的位置不在存在（不占位置了）。
2. absolute不受父元素里的其他元素影响，而relative会受到父元素里的其他元素影响
3. relative相对的总是**自身原来的位置**，无论其父元素是何种定位方式，而absolute总是相对于最近**定义为absolute或relative的父层元素**

### 盒模型

两种盒模型：标准盒模型、IE盒模型
相同点：都是由 content + padding + border + margin构成
不同点：盒子内容的宽/高度
标准盒模型： 只包含content    box-sizing: content-box
IE盒模型： content + padding + border box-sizing: border-box

### 选择器及其优先级

!important > style(内联) > id > class

### 隐藏元素的方法有哪些

1. `display:none`
2. `visibility:hidden`
3. `opacity:0`
4. `position:absolute; top:9999px`
5. `z-index: -100`
6. `clip-path: circle(0)`
7. `transform:scale(0,0)`

### CSS3中有哪些新特性

1. 新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点） :nth-child  :nth-of-type
2. 圆角 （border-radius:8px）
3. 多列布局 （multi-column layout） flex布局
4. 阴影和反射 （Shadoweflect） box-shadow
5. 文字特效 （text-shadow）
6. 文字渲染 （Text-decoration）
7. 线性渐变 （gradient） linear-gradient  radial-gradient
8. 旋转 （transform）
9. 增加了旋转,缩放,定位,倾斜,多背景 transition
10. animation

### display:none 与 visibility:hidden 的区别

- 在渲染树中
`display:none`会让元素完全从渲染树中消失，渲染时不会占据任何空间；
`visibility:hidden`不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。
- 是否是继承属性
display:none是**非继承**属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示 display修改会触发**重排**
visibility:hidden是**继承**属性，子孙节点消失是由于继承了hidden，通过设置visibility:visible可以让子孙节点显示 visibility修改只会造成本元素的**重绘**

### 对 requestAnimationframe 的理解

requestAnimationframe： 请求动画帧 
告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画
`window.requestAnimationFrame(callback);`
callback是下一次重绘之前更新动画帧所调用的函数
是 宏任务
cancelAnimationFrame(id)来取消执行动画，参数是requestAnimationFrame默认返回的id

#### 优势

1. CPU节能
   1. 使用SetInterval 实现的动画，当页面被隐藏或最小化时，SetInterval 仍然在后台执行动画任务
   2. RequestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。
2. 函数节流 
   1. 高频率事件( resize, scroll 等)中，RequestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，因为多数显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来
3. 减少dom操作
   1. requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成
##### 另一种说法
1. requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
2. 在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量。

#### setTimeout执行动画的缺点

它通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象。

1. settimeout任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚。
2. settimeout的固定时间间隔不一定与屏幕刷新间隔时间相同，会引起丢帧。

### css和js实现动画分别有哪些优缺点

1. css优点
   1. 硬件加速  会用gpu进行硬件加速，，更加流畅和高效运行
   2. 简单易用  通常几行代码就可实现
   3. 低资源占用  使用更少的cpu和内存资源
2. css缺点
   1. 限制较大 不能自由控制动画的速度和方向
   2. 兼容性问题 不同浏览器对css动画支持程度不同，要考虑兼容性
   3. 可维护性差 当效果复杂时，css代码会变的冗长和难以维护

### js中阻止事件冒泡和默认行为
1. 事件冒泡  event.stopPropagation()
2. 事件默认行为 event.preventDefault()

### reflow（重排/回流）和 repaint（重绘）理解

#### 重排/回流：
**第一次确定节点的大小和位置，称为布局，之后针对节点大小，位置改变重新计算称之为回流**
元素的**几何信息**被影响导致浏览器需要**重新计算**元素在视口内的几何属性（位置和尺寸）

#### 引发回流的几种情况
1. DOM结构发生变改变，如添加新的节点或者移除节点
2. 改变布局，如修改了width height padding font-size等值。
3. 改变窗口 resize,修改了窗口的尺寸。
4. 调用 getComputedStyle方法获取尺寸、位置信息。

#### 重绘：
**第一次渲染内容称之为绘制，之后重新渲染称之为重绘**
通过构造渲染树和重排（回流）阶段，我们知道了可见节点的样式和具体的几何信息，接下来将渲染树的每个节点转换为屏幕上的**实际像素**的阶段

#### 引发重绘的几种情况
修改背景色、文字颜色、边框颜色、样式等。

### 如何减少重排和重绘

- 最小化重绘和重排，修改样式尽量集中一次性修改
- 尽量避免频繁的操作DOM
- 批量操作DOM 比如读取某元素 offsetWidth 属性存到一个临时变量，再去使用，而不是频繁使用这个计算属性；又比如利用 `document.createDocumentFragment()` 来添加要被添加的节点，处理完之后再插入到实际 DOM 中
- 尽量避免通过 `getComputedStyle` 获取尺寸位置信息
- 使用 **absolute** 或 **fixed** 使元素脱离文档流，这在制作复杂的动画时对性能的影响比较明显
- 开启 GPU 加速，利用 css 属性 transform 、will-change 等，比如改变元素位置，我们使用 translate 会比使用绝对定位改变其 left 、top 等来的高效，因为它不会触发重排或重绘，transform 使浏览器为元素创建⼀个 GPU 图层，这使得动画元素在一个独立的层中进行渲染(每个合成层都是单独渲染的)。当元素的内容没有发生改变，就没有必要进行重绘 TODO:D

[参考](https://juejin.cn/post/6844903779700047885)

### 为什么有时候⽤translate来改变位置⽽不是定位？

1. translate 是 transform 属性的⼀个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合。
2. transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此translate()更⾼效，可以缩短平滑动画的绘制时间。

### BFC 的理解

block format context: 块级格式上下文 相当于一个独自的渲染区域 （内部布局不会影响外部）

#### 特点

1. 父元素垂直外边距不会与子元素重叠
2. bfc的元素不会被浮动元素覆盖
3. 开启bfc的元素可以包含浮动元素

### 作用

1. 清除浮动主要是为了解决父元素因为子级元素浮动引起的内部高度为0的问题
2. 处理外边距塌陷问题
3. 使浮动元素不遮挡普通元素

#### 如何开启bfc

1. overflow:hidden
2. before after伪类 clear:both

### 实现两栏布局（左侧固定和右侧自适应） 5 种

1. 浮动
左侧元素宽度固定，向左浮动，右边元素margin-left设为固定宽度，**width:auto**
2. 浮动
左边元素宽度固定 ，设置向左浮动。右侧元素设置 **overflow: hidden;** 这样右边就触发了 BFC ，BFC 的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。
3. flex
左边固定宽度，右边**flex:1**
4. 绝对定位
左边元素absolute，宽度固定，右边margin-left设为左边元素的宽度
5. 绝对定位
左边元素宽度固定，右边元素 absolute  定位， left  为宽度大小，其余方向定位为 0

### 实现圣杯布局和双飞翼布局（三分栏）

#### 目的：
1. 三栏布局，中间一栏最先加载和渲染（内容最重要，中间内容在html中最先写好从而最先加载）。
2. 两侧内容固定，中间内容随着宽度自适应。
3. 一般用于 PC 网页。

#### 技术总结
1. 使用 float 布局。
2. 两侧使用 margin 负值，以便和中间内容横向重叠。
3. 防止中间内容被两侧覆盖，圣杯布局用(父元素) padding ，双飞翼布局用（子元素） margin 

### 水平垂直居中的实现

1. 绝对定位 **不需要管宽高**
```css
.father {
  position: relative;
}
.son {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
}
```

2. 绝对定位 各方向为0 margin设为auto  盒子必须有宽高
```css
.father {
  position: relative;
}
.son {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0px;
  margin: auto;
  height: 100px;
  width: 100px;
}
```
3. 绝对定位 left和top定位之后通过margin-left和margin-top修改  必须有宽高
```css
.father {
  position: relative;
}
.son {
  position: absolute;
  left: 50%;
  top: 50%;
  width: 200px;
  height: 200px;
  margin-left: -100px;
  margin-top: -100px;
}
```
4. flex 不定宽高
```css
.father {
  display: flex;
  justify-content: center;
  align-items: center;
}
```

### flex：1 的含义

flex-grow: 1 ：该属性默认为 0 ，如果存在剩余空间，元素也不放大。设置为 1  代表会放大。
flex-shrink: 1 ：该属性默认为 1 ，如果空间不足，元素缩小。
flex-basis: 0% ：该属性定义在分配多余空间之前，元素占据的主轴空间。浏览器就是根据这个属性来计算是否有多余空间的。默认值为 auto ，即项目本身大小。设置为 0%  之后，因为有 flex-grow  和 flex-shrink  的设置会自动放大或缩小。在做两栏布局时，如果右边的自适应元素 flex-basis  设为 auto  的话，其本身大小将会是 0 .

### line-height 如何继承

1. 父元素的 line-height 写了具体数值，比如 30px，则子元素 line-height 继承该值。
2. 父元素的 line-height 写了比例，比如 1.5 或 2，则子元素 line-height 也是继承该比例。
3. 父元素的 line-height 写了百分比，比如 200%，则子元素 line-height 继承的是父元素 font-size * 200% 计算出来的值。

### 文字超出省略，用什么css

#### 单行文字

```css
#box1 {
    border: 1px solid #ccc;
    width: 100px;
    white-space: nowrap; /* 不换行 */
    overflow: hidden;
    text-overflow: ellipsis; /* 超出省略 */
}
```
#### 多行文字
```css
#box2 {
    border: 1px solid #ccc;
    width: 100px;
    overflow: hidden;
    display: -webkit-box; /* 将对象作为弹性伸缩盒子模型显示 */
    -webkit-box-orient: vertical; /* 设置子元素排列方式 */
    -webkit-line-clamp: 3; /* 显示几行，超出的省略 */
}
```

### 怎么画一条0.5px的线

1. height: 1px; transform: scale(0.5)
注意宽度也会变化，记得将宽度设为本来的200%

### 网页中有大量图片加载很慢，怎么优化

1. 图片懒加载 监听滚动条事件，判断图片位置与浏览器顶端和页面的距离，前者小于后者，优先加载
2. 使用图片预加载技术，将当前展示图片的前一张和后一张优先下载
3. csssprite和svgsprite

## js 相关

### ["1","2","3"].map(parseInt)值是啥

[1,NaN,NaN] 因为parseInt需要两个参数val,radix
map传了3个(element,index,array) 对应的radix不合法导致解析失败

callback函数的执行规则
参数：自动传入三个参数
currentValue（当前被传递的元素）；
index（当前被传递的元素的索引）；
array（调用map方法的数组）

["1","2","3"].map(v => parseInt(v)) 可以解析成功

### js的基本数据类型

undefined null boolean number string 

### js 的内置对象

数据封装类对象： Object Array Boolean Number String
其他对象： Function Arguments Math Date RegExp Error

### js的延迟加载方式有哪些

1. 动态创建script元素 并将其添加到DOM中 `var sc = document.createElement('script') script.src = 'a.js' document.body.appendChild(sc)`
2. 使用defer属性，将脚本执行推迟到文档解析完成后再执行  async也可以
3. 动态加载模块 import和export 可以使用动态import方法来延迟加载
`import("path/module.js").then(res => {}).catch(err => err)`

### 同源和跨域

#### 同源
指：域名www、协议http、端口8080相同。

同源策略是浏览器的行为，是为了保护本地数据不被JavaScript代码获取回来的数据污染，因此拦截的是客户端发出的请求回来的数据接收。即请求发送了，服务器响应了，但是无法被浏览器接收

#### 跨域

若干标签可以允许跨域
1. img
2. link href
3. script src

#### ajax跨域问题

cors 跨域资源共享 服务端进行配置即可

jsonp 

首先是利用script标签的src属性来实现跨域。
服务端返回一个定义好的js函数的调用，并且将服务器的数据以该函数参数的形式传递过来，这个方法需要前后端配合。
缺点：
1. 只支持get，且需要后端配合
2. 有可能有恶意代码
3. 要确定 JSONP 请求是否失败并不容易。虽然 HTML5 给 script 标签新增了一个 onerror 事件处理程序，但是存在兼容性问题

`var str = params.query.callback + '(' + JSON.stringify(data) + ')';`

### 箭头函数与普通函数的区别

1. 箭头函数没有this，它只会从自己作用域链上一层继承this，call，apply，bind也不能改变this指向
2. 箭头函数没有自己的arguments对象向，可以再箭头函数中使用rest参数替代arguments来访问箭头函数的参数列表 `(...args) => {}`
3. 箭头函数不能通过new关键字调用，没有原型，super，new.target值等

### ES6新特性

1. let const 块级作用域
2. 模板字符串 `${muban}`
3. 展开运算符 `...arr`
4. 箭头函数  `() => {}`
5. 解构赋值 `let {name} = obj`
6. 类语法糖class
7. map set数据结构

### call apply bind 函数的区别

call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，即修改函数体内this的指向

call和apply用法类似，call方法接受的是参数列表即多个参数以逗号分隔，而apply方法接受的是一个参数数组
```js
func1(arg1,arg2) {}
func.apply(func1,[arg1,arg2]) //参数数量不确定时，可以通过arguments把参数全部push进去
func.call(func1,arg1,arg2)
```

**bind**和call/apply最大的区别，一个函数被call和apply的时候会立即执行函数，但是bind会创建一个**新函数**，**不会立即执行**

### new函数创建实例对象的步骤

1. 创建一个空对象obj
2. 将obj的原型指向构造函数，这样obj就可以访问到构造函数的原型
3. 执行构造函数，this指向obj，这样obj就可以访问到构造函数的属性
4. 返回obj

1. 创建一个新的对象
2. 继承父类原型上的方法.
3. 添加父类的属性到新的对象上并初始化. 保存方法的执行结果.
4. 如果执行结果有返回值并且是一个对象, 返回执行的结果, 否则, 返回新创建的对象。

```js
function createNew(Fn, ...args) {
  const newObj = Object.create(Fn);
  const res = Fn.apply(newObj, args);
  return typeof res === "object" ? res : newObj;
}
```

### 值类型和引用类型的区别

值类型的变量直接存储数据（**栈**上），而引用类型的变量持有的是数据的引用（地址），数据存储在数据**堆**中。

引用类型：当**声明**一个类时，只在**栈**中分配一小片内存用于容纳一个地址，而此时并没有为其分配堆上的内存空间。当使用 **new** 创建一个类的实例时，分配**堆**上的空间，并把堆上空间的地址保存到栈上分配的小片空间中。


### typeof 能判断哪些类型

所有类型：undefined null(特殊引用类型，指向空地址) string number boolean symbol function(特殊引用类型)

1. 识别所有值类型
2. 识别函数 返回 'function'
3. 判断是否是引用类型

注意： typeof null | [1,2]  => "object"

### === 和 == 的区别

== 只要求值相等即可 即经过类型转换为同一类型后值相等即可
=== 不仅值相等 类型也要相同

使用过程中，除了 == null 之外，其他一律用 === 
if(obj.a == null) 等价于 if(obj.a === null || obj.a === undefined)

truly变量： !!a === true的变量
falsely变量  !!a === false的变量 ( 0 NaN "" null undefined false )

逻辑判断：
10 && 0 前面是truly值，&&直接返回后面的值
"" || 'abc' 前面是falsely值， ||直接返回后面的值

### 为啥 0.1+0.2 ！== 0.3

是由于浮点数运算的精度问题（精度是有限的）导致等式左右的结果不严格相等
浮点数转成二进制是无限循环的，所以计算机中只能存储一个近似值

正确的比较方法 是使用js提供的最小精度值 Number.EPSILON
`Math.abs(0.1+0.2-0.3) <= Number.EPSILON`

### 原型及原型链

原型：
每个class都有显式原型prototype
每个class实例化后的对象都有隐式原型__proto__
实例的隐式原型指向对应class的显式原型
class类具有定义的属性和方法，也有显式原型prototype。而将这个class类实例化后就有了隐式原型__proto__，即shilihua.proto === Student.proptotype

原型链：
首先，每个对象在初始化的时候都会被添加上__proto__属性，指向该对象的原型对象，同时在js中万物皆对象，所以该对象的原型对象也有__proto__属性指向它的原型对象，这样一直指下去就会形成一个原型形成的链，简称原型链。

#### 原型对象对实例的作用

如果要给一个构造函数Foo创建出来的多个实例都添加一个方法，就可以在实例的原型上添加对应的方法，这样这个原型的所有实例便都有这个方法了

prototype是函数独有的属性 从一个函数指向一个对象 是该函数的原型对象
proto属性是所有对象都有的，它指向构造函数的原型对象

### 如何判断一个变量是不是数组

1. param instanceof Array (return true/false)
2. Array.isArray 更好 因为能检测iframes

xialuo instanceof Student  (true)

### class的原型本质，怎么理解

TODO:原型和原型链的图示

class可以理解为一个模板，本质就是一个函数，通过constructor构造方法来构造一些属性和方法，然后通过new关键字来实例化这个类
继承： 子类在自身的constructor方法中用super关键字调用父类的constuctor方法

### js的几种继承方式 
TODO:重新整理

- 原型链继承：

优点：通过原型继承多个引用类型的属性和方法

缺点：Sub原型变成了Super的实例，如果Super的实例某个属性是引用值，该引用值就会被应用到所有Sub创建的实例中去，会有污染问题。

- 借用构造函数

优点：每个实例都会有自己的a属性，哪怕是引用值也不会被污染

缺点：Super构造函数中的方法在每个实例上都要创建一遍（除非该方法声明提到全局）

- 组合继承

优点： 集合了原型继承和盗用构造函数继承的优点

缺点：存在效率问题，Super始终会被调用两次

- 原型式继承

优点：对一个对象进行浅克隆创建另一个对象，同时继承该对象的原型属性

缺点：由于是浅克隆，所以实例共享的对象属性如果是引用值，会受污染

- 寄生式继承

优点：根据一个对象克隆创建另一个对象，并增强对象

缺点：同【盗用构造函数继承】方法在每个实例上都要创建一遍

- 寄生式组合继承

优点：集合了【原型式继承】和【盗用构造函数继承】的优点，效率比【组合继承】更高。

### js创建对象的几种方式

1. 工厂模式
```js
function createPerson(name,age) {
  let a = new Object();
  a.name = name;
  a.age = age;
  return a
}
let p1 = createPerson("mike",12)
```
2. 对象字面量 `let person = { name: 'mike' }`
3. 构造函数 
```js
function Person(name,age) {
  this.name = name;
  this.age = age;
}
let p1 = new Person("mike",12)
```
4. 原型模式
```js
function Dog() {}
Dog.prototype.name = "dog1"
let newDog = new Dog()
```
5. 混合模式  即构造函数+原型

### 作用域和作用域链

作用域（scope） ：作用域就是一个独立的地盘，让变量不会外泄、暴露出去。作用域最大的用处就是**隔离变量**，不同作用域下的同名变量不会有冲突。

- 全局作用域 （最外层定义的变量和函数，未定义并直接赋值的变量-变量提升，window对象的属性）
- 函数作用域 （函数内部定义的变量）
- 块级作用域 （let const声明的变量）

作用域链

- 自由变量 当前作用域中没有定义的变量，称为自由变量。
- 作用域链  访问变量时，自己的作用域中没有，一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃，这种一层一层的关系，就是作用域链
- 作用域与执行上下文的区别
  - 解释阶段（作用域规则确定）
  - 执行阶段（执行上下文）

执行上下文在**运行时**确定（this的指向问题），随时可能改变，作用域（变量的值）在**解释阶段（类似编译）**就确定，并且不会改变。


### 执行上下文

是js代码执行的一个环境，存放了代码执行所需的变量，变量查找的作用域链规则以及this指向等

### 什么是块级作用域

任何一对花括号({})中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。es6才有的

每个执行上下文都分为 变量环境 和 词法环境
var声明的变量在编译阶段都被存放到变量环境中，let声明的变量在编译阶段会被存放到词法环境中

块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎也就同时支持了变量提升和块级作用域了

### 闭包
怎么回答： 怎么实现闭包 为啥要用闭包 那些地方会用到闭包

1. 有权访问其他函数作用域中变量的函数

2. 闭包是指那些能够访问自由变量的函数。 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。 闭包 = 函数 + 函数能够访问的自由变量

所有（闭包）自由变量的查找 是在函数定义的地方，向上级作用域查找 不是在执行的地方

#### 怎么创建闭包

在一个函数内部创建另一个函数

#### 闭包的作用

可以读取函数内部的变量
可以阻止变量被回收

#### 为啥要用闭包

利用闭包可以突破链作用域，将局部变量传到内部

#### 闭包的缺点

比普通函数更加占用内存，可能造成内存泄漏，不会被垃圾回收机制回收

#### 闭包的实际应用场景

1. 循环绑定监听事件,给标签循环添加监听事件 
解决方式：1. 立即执行函数 2. es6声明 let const等（如下）
```js
let a,i
for(i=0;i<10;i++) {
  // 这里面的i都是10
}
// 正确写法
let a
for(let i=0;i<10;i++) {
  // 这里都是块级作用域
}
```

2. 节流防抖
在函数外部定义的timer,返回的是个函数，在函数内部修改timer的值实现定时效果

3. setTimeout 自执行方法
4. 所有的回调函数

### 哪些操作可能引起内存泄漏
1. 不需要的全局变量  注册在window对象下的变量 var声明的变量
2. 计时器和回调函数timers 定时器不被需要时，没有被clear
3. DOM泄漏  元素引用没有清理  var a = document.getElementById('id')需要a=null来清理
4. js闭包
5. console.log

### 深浅拷贝的几种实现方式

#### 浅拷贝
1. Object.assign() let b = Object.assign({},a)
2. 扩展运算符 let b = {...a}
3. Object.create()  let b = Object.create(a, Object.getOwnPropertyDescriptors(a))

#### 深拷贝
1. JSON.stringify 会忽略value为undefined symbol 和function的属性 还有bigInt值会报错
2. deepCopy 递归实现
3. lodash.cloneDeep()
4. jquery中的extend()方法  let newObj = $.extend(true,{},obj1)

### require 和 import

1.import在代码编译时被加载，所以必须放在文件开头，require在代码运行时被加载，所以require理论上可以运用在代码的任何地方，所以import性能更好。
2.import引入的对象被修改时，源对象也会被修改，相当于浅拷贝，require引入的对象被修改时，源对象不会被修改，官网称值拷贝，我们可以理解为深拷贝。
3.import有利于tree-shaking（移除JavaScript上下文中未引用的代码），require对tree-shaking不友好。 
4.import会触发代码分割（把代码分离到不同的bundle中，然后可以按需加载或者并行加载这些文件），require不会触发。
5.import是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法，require 是 AMD规范引入方式。

### promise理解

promise是ES6中为了避免回调地狱的一种异步解决方案

#### 特点
1. 状态不受外界影响
2. 状态一旦改变就不会再变

#### 实例对象方法
1. then
2. catch
3. finally
4. resolve() reject()
5. all() 所有resolved 才是resolved 其他都是rejected
6. race() 第一个完成状态变化的成功了最终就是resolved 失败就是rejected
7. any() 有一个成功就resolved，都失败就rejected
8. allSettled() then接收的参数是所有promise对象异步操作的执行结果 如下
```js
[
  {status: 'fulfilled', value: 42 },
  {status: 'rejected', value: -1 }
]
```

### promise简易实现

其中有点类似发布订阅模式 收集依赖 触发通知 取出依赖执行

```js
const PENDING = 'PENDING';
const FULFILLED = 'FULFILLED';
const REJECTED = 'REJECTED';

class Promise {
  constructor(executor) {
    this.status = PENDING;
    this.value = undefined;
    this.reason = undefined;
    // 存放成功的回调
    this.onResolvedCallbacks = [];
    // 存放失败的回调
    this.onRejectedCallbacks= [];

    let resolve = (value) => {
      if(this.status ===  PENDING) {
        this.status = FULFILLED;
        this.value = value;
        // 依次将对应的函数执行
        this.onResolvedCallbacks.forEach(fn=>fn());
      }
    } 

    let reject = (reason) => {
      if(this.status ===  PENDING) {
        this.status = REJECTED;
        this.reason = reason;
        // 依次将对应的函数执行
        this.onRejectedCallbacks.forEach(fn=>fn());
      }
    }

    try {
      executor(resolve,reject)
    } catch (error) {
      reject(error)
    }
  }

  then(onFulfilled, onRejected) {
    if (this.status === FULFILLED) {
      onFulfilled(this.value)
    }

    if (this.status === REJECTED) {
      onRejected(this.reason)
    }

    if (this.status === PENDING) {
      // 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行
      this.onResolvedCallbacks.push(() => {
        onFulfilled(this.value)
      });

      // 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行
      this.onRejectedCallbacks.push(()=> {
        onRejected(this.reason);
      })
    }
  }
}
```


### 迭代方法 数组遍历方法

1. every 有一个不满足返回false，都满足返回true  不会改变原数组
2. some   有一个元素满足要求返回true，否则false 不改变原数组
3. forEach  返回undefined                 不改变原数组
4. filter  返回新数组，元素为符合条件的所有元素  不改变原数组
5. map  返回新数组，元素为调用函数处理后的值    不改变原数组（性能比forEach低）
6. find  返回第一个满足的项或者undefined     不改变原数组
7. findIndex 返回第一个满足的项的下标或者-1     不改变原数组

其他
1. for
2. forin  对象 效率最低
3. forof  数组 支持break等，缺点没有index

普通for循环才是最优雅的，优化后的for循环最快
数组方法无法中途停止循环，所以都不可以使用break和continue；
for循环之类的不可以return，但是能正常使用break和continue；

#### 其他数组方法

join()
push()和pop()
shift() 和 unshift()
sort()
reverse()
concat()
slice()
splice()

### slice和splice区别

1. slice(start,end)
   1. 从start截取到end 但是不包括end
   2. 返回值为截取出来的元素的集合
   3. 原始数组不会发生变化

2. splice(start,deleteCount,items)
   1. start参数 开始的位置 
   2. deleteCount要截取的个数
   3. items要添加的元素
   4. 返回值是被删除的元素组成的一个数组，如果没删除元素就返回空数组
   5. 会改变原数组，数组长度会发生变化

### shift 和 unshift 和 push 和 pop的返回值
shift 和 pop 返回值 被删除的值
unshift 和 push 返回添加之后数组的长度

### map 和 set的区别

map 字典 键值对 set get has size 
set 值唯一的数组 add delete has clear size  set.delete(3)删除元素不需要知道索引

### map和weakMap的区别

1. 键类型： Map对象的键可以使任何类型，包括基本数据类型和对象类型，WeakMap对象的键必须是对象类型
2. 垃圾回收：Map对象中的键和值都会被常规垃圾回收机制回收，而weakMap中的键是弱引用，即在对象被垃圾回收时，weakmap中对应的键值对也会被自动删除，这使得weakmap通常用于缓存，当对象不被使用时，weakmap可以自动清除对应的数据
3. map对象内部有内置的迭代器，可以通过for of循环来遍历，而weakmap没有内置的迭代器，不能直接遍历

### 垃圾回收机制

任务：找到**哪些被分配的内存确实已经不再需要了**

1. 引用计数垃圾收集
理解为 对象有没有其他对象引用它，如果没有就标记为**零引用**，对象将被垃圾回收机制回收
限制：循环引用的风险

2. 标记-清除算法
理解为 对象是否可以获得 假定设置一个root对象，垃圾回收器会定期从根开始找所有从它开始引用的对象，如果从全局对象无法获取的对象则会被垃圾回收器回收
限制: 那些无法从根对象查询到的对象都将被清除（一般没问题）


### this 的用法及含义

**this取什么值是在函数被执行的时候确定的，不是在定义的时候。this总是指向函数的直接调用者**

this的指向问题
1. 作为普通函数 window  setTimeout注意（也是指向window，可以用箭头函数修改指向为外部调用者）
2. 使用call bind apply （call可直接换this指向 bind是有返回值 返回值再调用）
3. 作为对象方法被调用 指代的就是这个对象本身
4. 在class方法中调用 当前实例本身 
5. 箭头函数  `()=>{this}` 和上级作用域的值一致

### web 存储

1. cookie
   1. 特点
      1. 本身用于浏览器和server端的信息传递，以小文本文件形式保存登录凭证等
      2. 可用`document.cookie = 'xxx'`来修改
   2. 缺点
      1. 存储大小限制为4KB
      2. http请求需要发送到服务端，增加请求数量
      3. 只能用document.cookie修改，需要自己封装处理cookie的方法
2. localStorage 和 sessionStorage
   1. 特点
      1. 最大可存储 5MB
      2. api 简单易用，setItem getItem
      3. 不会跟随 http 请求发送给服务端
   2. 区别
      1. localStorage 会永久存储，除非手动删除
      2. sessionStorage 数据只存在当前会话，浏览器关闭则清空
      3. 一般用 localStorage 较多

#### cookie的详细理解

##### 属性
可以用document.cookie查看，格式是由键值对构成的字符串以分号空格分割
注意只能获取非httponly下的
expires  过期时间
HttpOnly  设置能否用js访问，一旦携带这个属性，客户端无法通过js访问这个cookie
secure  只有在https情况下才能发送至服务器端

服务端可以设置cookie 的所有选项

### http 缓存（强制缓存 | 协商缓存）

#### 为什么需要缓存？ 

网络请求相比于 CPU 的计算和页面渲染是非常非常慢的。

#### http缓存机制

http 缓存机制主要在http相应头中设定，响应头中相关字段为 Expires,Cache-Control,Last-Modified,If-Modified-Since,Etag 等
1. Expires http1.0的规范，值是一个绝对时间的GMT格式，在此时间之前，本地缓存始终有效。有个缺点，服务端和客户端时间偏差较大时会出现缓存混乱的问题
2. Cache-Control 是http1.1的规范，一般用max-age表示
   1. max-age：用来设置资源（representations）可以被缓存多长时间，单位为秒
   2. s-maxage：和max-age是一样的，不过它只针对代理服务器缓存而言；
   3. public：指示响应可被任何缓存区缓存；
   4. private：只能针对个人用户，而不能被代理服务器缓存；
   5. no-cache：强制客户端直接向服务器发送请求,也就是说每次请求都必须向服务器发送。服务器接收到请求，然后判断资源是否变更，是则返回新内容，否则返回304，未变更。这个很容易让人产生误解，使人误以为是响应不被缓存。实际上Cache-Control: no-cache是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。
   6. no-store：禁止一切缓存（这个才是响应不被缓存的意思）。

Cache-Control 与 Expires 可以在服务端配置同时启用，同时启用的时候 Cache-Control 优先级高。
#### 强制缓存

就是利用上面expires和cache-control中的max-age实现
过程：
1. 初次请求，服务器返回资源和cache-control/expires
2. 再次请求，本地缓存直接返回资源

#### 协商缓存（对比缓存）

- 服务端缓存策略。
- 服务端判断客户端资源，是否和服务端资源一样。
- 一致则返回 304，否则返回 200 和最新的资源。
过程：
1. 初次请求，服务器端返回资源和资源标识
2. 再次请求时带着资源标识，服务器端返回304，或返回资源（200）和新的资源标识

资源标识：保存在Response Headers中
1. Last-Modified： 资源的最后修改时间
2. Etag： 资源的唯一标识

##### Last-modified  If-Modified-Since
服务端拿到 if-Modified-Since 之后拿这个时间去和服务端资源最后修改时间做比较，如果一致则返回 304 ，不一致（也就是资源已经更新了）就返回 200 和新的资源及新的 Last-Modified。
##### Etag  If-None-Match
其实 Etag 和 Last-Modified 一样的，只不过 Etag 是服务端对资源按照一定方式（比如 contenthash）计算出来的唯一标识，就像人类指纹一样，通过 **If-None-match**（就是Etag的值） 传给客户端之后，客户端再传过来时候，服务端会将其与现在的资源计算出来的唯一标识做比较，一致则返回 304，不一致就返回 200 和新的资源及新的 Etag。

#### 总结
Etag的优先级比last-modified高

last-modified的不足：
1. 只能精确到秒级，如果一个文件一秒内多次修改，不能准确标注文件的修改时间
2. 如果一个文件定期生成且内容没有变化，last-modified也会改变，导致无法使用缓存

### 异步

异步就是当某一代码执行异步过程调用发出后，这段代码不会立刻得到返回结果，而是在异步调用发出之后，一般通过回调函数处理这个调用之后拿到结果。异步调用发出后，**不会影响阻塞**后面的代码执行

1. 最开始实现异步都是采用**回调函数**实现的，但是有个缺点：回调地狱
2. 为了解决回调地狱的问题，ES6提出了Promise的方式 （Generator配合yield方式）
3. ES7又提出新的异步解决方案 async/await async是Generator函数的语法糖，优点是使异步逻辑的代码跟同步一样容易理解

### event loop

异步任务不进入主线程，而是进入**任务队列**，当主线程中的任务执行完毕，就从任务队列中取出任务放进主线程中来进行执行。由于主线程不断重复的获得任务、执行任务、再获取再执行，所以这种机制被叫做事件循环。

1. 执行一个宏任务（栈中没有就从事件队列中获取）
2. 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
4. 当前微任务执行完毕，开始检查渲染，然后GUI线程接管渲染
5. 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）

总结：
1. tasks 按序执行，浏览器会在 tasks 之间执行渲染。
2. microtasks 按序执行，在下面情况时执行：
   1. 在每个回调之后，只要没有其它代码正在运行。
   2. 在每个 task 的末尾

### 宏任务微任务

异步任务队列不只一个，根据任务种类分为微任务队列(micro task/ Task)和宏任务队列(macro task/Jobs)

宏任务 -（当前微任务） - 渲染 - 宏任务 。。。

**微任务比宏任务执行时间要早**

常见宏任务：
1. setTimeout
2. setInterval
3. setImmediate(Node)
4. 点击事件或键盘事件 i/o事件
5. Ajax
6. script整体代码段
7. promise里面的代码

常见微任务
1. **promise.then**,**await**（与then类似）,promise.catch
2. object.observe
3. new MutationObserver(浏览器环境)
4. process.nextTick(node)

注意：async函数在await之前的代码都是**同步**执行的，可以理解为await之前的代码属于new Promise传入的代码，**await之后的代码都是在Promise.then中的回调**

### 柯里化

柯里化就是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术

```js
function sum(a,b,c) {
  return a+ b + c
}
// 柯里化之后
function sum(a) {
  return function(b) {
    return function(c) {
      return a + b + c
    }
  }
}
// 调用时
sum(1)(2)(3)
```

#### 柯里化的好处
我们处理函数时，希望函数功能尽可能单一

#### 自动柯里化
(个人感觉不重要，理解什么是柯里化即可)
```js
function myCurried(fn) {
  return function curry(...args1) {
    if (args1.length >= fn.length) {
      return fn.call(null, ...args1)
    } else {
      return function (...args2) {
        return curry.apply(null, [...args1, ...args2])
      }
    }
  }
}

function sum(a, b, c, d, e) {
  return a + b + c + d + e
}
let resFunc = myCurried(sum)
console.log(resFunc(1,3,4)(1)(23))
//解析:
//1、这里的fn.length获取的是函数传入参数的长度
//2、这里使用递归的思想
```

### 箭头函数的优缺点

#### 优点
1. 简写了函数
2. **改变this的指向为当前外部对象**

#### 缺点
1. 没有arguments参数
2. 无法通过apply bind call来改变this的指向

#### 不能用于哪些场景
1. 不能用于对象内方法
2. 不能用于对象原型
3. 不能用于构造函数
4. 动态上下文中的函数，addEventListener的回调函数，其中的this指向有问题
5. vue生命周期和method方法不能写成箭头函数的形式
```js
const obj = {
    a:'a'
    getA: () => {
        return this.a
    }
}
console.log( obj.getA() ) //undefined
```

### AMD 和 CommonJS 的理解

CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数
AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的

### animation的用法

animation的各个属性
`animation: name duration timing-function delay iteration-count direction fill-mode play-state`

name 关键帧名称 loop
duration 动画完成时间多少秒 3s
timing-function 设置如何完成一个周期 linear
delay 启动前延迟间隔 0.3s
iteration-count 播放次数 infinite
direction 是否反向播放动画
fill-mode 动画不播放时，要应用的元素样式
play-state 是否正在运行或暂停

### 如何使⽤ JavaScript 来判断⽤户设备类型，pc端还是移动端？
1. 利⽤ navigator.userAgent 属性来获取⽤户代理信息
```js
function isMobile() {
  return /Androd|webOS|iphone|iPad|iPad|BlackBerry|Mini/i.test(navigator.userAgent)
}
```
2. window.matchMedia('(max-midth:768px)').matches;
3. 第三方库 isMobile mobile-detect detect.js等

### sort的实现原理

此时排序的方式是按照ascii码进行排序，它会先将数组里的元素全部转为字符串(不影响原值)，方便比较。

### web开发中会话跟踪的方法有哪些

1：Cookie：
通过在用户浏览器中存储小型文本文件来跟踪会话状态信息。每次用户请求时，浏览器将Cookie数据包含在请求头中发送到服务器。
2：URL 重写：
将会话标识符添加到URL中作为查询参数的一部分。服务器通过解析URL中的会话标识符来跟踪会话状态。
3：隐藏表单字段（隐藏input）：
在HTML表单中添加一个隐藏字段，用于存储会话标识符。每次用户提交表单时，会话标识符将与请求一起发送到服务器。
4：会话存储（Session）：
在服务器端存储会话状态信息，并为每个会话分配一个唯一的标识符。服务器使用该标识符跟踪用户的会话状态。
5：HTML5 Web存储：
使用HTML5中的Web存储机制（如localStorage或sessionStorage）来存储会话状态信息。这些存储在客户端浏览器中，可以在整个会话期间保持不变

### setTimeout和setInterval都可以实现周期性调度（每隔几秒发送个请求）
例如，我们要实现一个服务（server），每间隔 5 秒向服务器发送一个数据请求，但如果服务器过载了，那么就要降低请求频率，比如将间隔增加到 10、20、40 秒等。

```js
let delay = 5000;
let timerId = setTimeout(function request() {
  ...发送请求...
  if (request failed due to server overload) {
    // 下一次执行的间隔是当前的 2 倍
    delay *= 2;
  }
  timerId = setTimeout(request, delay);
}, delay);
```

## jquery

### $.extend()用法

1. 浅拷贝  $.extend(a,b)  b拷贝a的内容
2. 深拷贝  $.extend(true,a,b)
3. jQuery.fn.extend()  这边的jQuery.fn是jquery原型  是为jquery类添加 成员函数，相当于扩展jquery对象方法

### jQuery队列是如何实现的，可以用在哪些地方

主要是用queue() dequeue() clearQueue() 主要用于animate ajax等需要按时间顺序执行的事件中

### jquery中bind live delagate on的区别

链接(https://www.cnblogs.com/gobiggirl/p/4498038.html)

## vue 相关

### vue3相关(https://juejin.cn/post/7139921537896808479)

### vue3的生命周期
onMounted onUpdated onUnmounted compositionAPI中使用方式 引入进来

beforeCreate created 这是options API中使用方式
beforeMount mounted
beforeUpdate updated
beforeUnmount unmounted  就这边变了

setup函数是在beforeCreate和created之间运行的，所以可以用它来代替这两个钩子函数
当然 也可以在setup之外写vue2的生命周期函数

### 为啥vue3没有this

我们在options api中对其中的一些属性进行绑定,但是在composition api中的setup函数的执行并没有绑定实例对象

### vue 和 react的区别 对比等

#### 共同点
1. 都是数据驱动视图
2. 都是组件化思想
3. 都有虚拟dom

#### 区别
1. vue是响应式的数据双向绑定系统，而react是单向数据流，没有双向绑定
2. vue相对语法简单，适用于小型项目，react更侧重于大型应用
3. vue渲染更快体积更小，react生态圈更大有更多工具

### vue 的优势

1. 轻量级框架
2. 双向数据绑定（即响应式数据绑定）  -- 最大优点
3. 组件化开发
4. 虚拟dom 节省了大量性能 比react快

### vue修饰符

事件修饰符
- stop 阻止事件继续传播
- prevent 阻止标签默认行为
- capture 使用事件捕获模式,即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理
- self 只当在 event.target 是当前元素自身时触发处理函数
- once 事件将只会触发一次
- passive 告诉浏览器你不想阻止事件的默认行为

v-model 的修饰符

- lazy 通过这个修饰符，转变为在 change 事件再同步
- number 自动将用户的输入值转化为数值类型
- trim 自动过滤用户输入的首尾空格

### vue的filter用法

#### 使用方式
` {{ xxx | filter1 | filter2（'arg1',arg1） }} v-bind:attr='xxx | attr' `
#### 定义方式
```js
// vue文件中定义
filters: {
  capitalize: function(value) {
    return value + ''
  }
}
// 全局定义 main.js文件中定义
Vue.filter('capitalize', function(value) {
  return ''
})
```

**局部过滤器**优先于全局过滤器被调用
实际开发中，可以将所有方法写在一个单独的js文件中，然后再main.js中引入全局注册即可
```js
import * as _filters from "./../"
object.keys(_filters).forEach(item => {
  Vue.filter(item,_filters[item])
})
```

### computed和watch区别
1. computed 依赖于其他属性值 并且computed的值有**缓存**
2. watch 监听某些数据的回调

### mvvm 和 mvc 区别

1. mvc和mvvm都是一种设计思想。 主要就是mvc中Controller演变成mvvm中的viewModel。 mvvm主要解决了mvc中大量DOM操作使页面渲染性能降低，加载速度变慢的问题 。
2. MVVM与MVC最大的区别就是：它**实现了View和Model的自动同步**：当Model的属性改变时，我们不用再自己手动操作Dom元素来改变View的显示，它会自动变化。 （数据变化页面直接跟着变化）
3. 整体看来，MVVM比MVC精简很多，我们不用再用选择器频繁地操作DOM。

### vue 双向绑定的原理

采用数据劫持和发布者-订阅者模式
数据劫持是通过 Object.defineProperty实现的，defineProperty可以控制对象属性的一些特有操作比如读写，是否可枚举等。其中最重要的就是get和set方法,可以通过defineProperty重写get和set方法来自定义对象属性的读取和设置。

```js
Object.defineProperty(Book, 'name', {
  set: function (value) {
    name = value;
    console.log('你取了一个书名叫做' + value);
  },
  get: function () {
    return '《' + name + '》'
  }
})
```

#### 具体的实现（了解）
1. 实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。
2. 实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。
3. 实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器

[参考](https://www.cnblogs.com/chenhuichao/p/10818396.html)

### vue2 和 vue3 双向绑定原理的区别 ：proxy

vue2如上
vue3采用的是proxy来实现双向绑定的

#### 为啥vue3要改用proxy

object.defineProperty的缺点
1. 因为只能监听对象的属性，所以需要深度遍历，监听需要一次性递归 (遍历每个对象的每个属性，如果对象嵌套很深的话，需要使用递归调用。
2. 无法监听新增属性/删除属性(Vue.set Vue.delete，未在 data 中定义的属性会报 undefined)
3. 无法原生监听数组，需要特殊处理（比如直接根据下标来修改值不能实时响应）

`let proxy = new Proxy(target,handler)`
proxy支持13种拦截方式，相比老版更加丰富

可以理解为在对象之前设置一个**对整个对象的拦截**，当监听的对象被访问的时候，都必须经过这层拦截。可以在这拦截中对原对象处理，返回需要的数据格式。

Reflect是ES6为了操作对象而新增的API，个人理解为之前Object的优化，并完美支持proxy

#### proxy的缺点
proxy 无法兼容所有浏览器，无法进行polyfill

### data 为啥是函数

因为**组件是可以复用**的, JS里对象是**引用**关系, 如果组件data是一个对象, 那么在子组件中的data属性值会**互相污染**, 产生副作用。所以一个组件的data选项必须是一个函数, 这样才让每个实例可以维护一份被返回对象的独立拷贝。

### ref是什么

引用
`this.$refs.refName`
加在普通元素 可以获取到对应的dom元素
加在子组件上，用this.ref.name 获取到的是组件实例，可以使用组件的所有方法

### data computed watch 的依赖关系

computed计算属性和watch都是以vue的依赖追踪机制为基础的，即依赖数据发生变化，所有一来这个数据的相关数据也自动发生变化
computed是一个值受多个属性影响
watch是监听一个属性的值发生变化时对其他多条数据的影响

### 为啥 v-for 和 v-if 不建议一起用

当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。这意味着 v-if 将分别重复运行于 每个 v-for 循环中，即先运行 v-for 的循环，然后在每一个 v-for 的循环中，再进行 v-if 的条件对比，会造成性能问题，影响速度。

建议使用计算属性替代

### 插槽（匿名，具名，作用域）及用法

#### 匿名插槽

`<slot />`

#### 具名插槽  一一对应即可

子组件
``` vue
<slot name="header"></slot>
<slot name="footer"></slot>
```
父组件
```vue
<h1 slot="header">h1</h1>
<h1 slot="footer">h1</h1>
```

#### 作用域插槽 - 带数据的插槽 可用slot-scope获取数据

- 子组件中
`<slot  :data="data"></slot>` 
- 父组件
``` vue
<template slot-scope="user">
  <div class="tmpl">
    <span v-for="item in user.data">{{item}}</span>
  </div>
</template>
```

### vue 的生命周期

1. beforeCreate 刚创建实例，没有数据和计算属性等 可以访问到 $el 和 $options
2. created 实例创建完，可以访问data和methods，$el上的属性还不存在
3. beforeMount 实例已挂载到dom上，但是dom还没更新
4. mounted 实例已挂在到dom，dom已更新，`$el`属性可见，用`this.$el`可以访问
5. beforeUpdate data已更新，dom未更新
6. updated dom和data都更新完毕
7. beforeDestory 实例销毁前，此时事件监听和watcher都已移除，但是dom还没移除
8. destoryed 实例销毁后，事件监听和watcher和dom都移除
9. activated  keep-alive激活时调用
10. deactivated  keep-alive停用时调用
11. errorCaptured 捕获子组件的错误 会向上冒泡 可以在此处进行错误处理

beforeDestory注意点
自定义的全局事件要在退出该页面钱进行解绑
```js
mounted () {
  window.addEventListener('scroll', this.handleScroll)
},
beforeDestroy () {
  window.removeEventListener('scroll', this.handleScroll)
}
```

### 组件之间的传值

1. 父 -> 子  props
2. 子 -> 父  events($emits)
3. $parent / $children 两种都是直接得到组件实例，使用后可以直接调用组件的方法或访问数据。
4. 总线机制bus event bus  ($emit $on)
要创建一个公共bus.js 然后在其他组件中引入 作为中间传达的工具
1. vuex
2. $attrs  / $listeners  两个对象 $attrs是非props属性 $listeners是非原生事件 `v-bind="$attrs"`
3. 祖 -> 孙 provide / inject

### keep-alive的属性
- include 名称匹配的会被缓存
- exclude 名称匹配的都并不缓存 类型为字符串或正则表达式
- max 最多可以缓存的组件实例数量限制，超过时，会从最早缓存的组件开始销毁

钩子函数执行顺序:
当使用keep-alive时，如果组件页面首次进入则钩子的触发顺序为 created -> mounted -> activated，组件切换时，触发 deactivated，再次切换进入时，只会触发activated

### vue 循环为啥要加 key

类似唯一身份标志，主要用来做dom diff算法用的

diff算法是同级比较，比较当前标签上的key还有它当前的标签名，如果key和标签名都一样时只是做了一个移动的操作，不会重新创建元素和删除元素

默认使用 就地复用的策略，

#### 为啥不能用index做key

1. 性能问题：如果在数组前新增一个新元素，整个数组的key都发生了变化，就跟没有key是一个效果了  （在对数据进行，逆序添加，逆序删除等破坏顺序的操作时，会产生没必要的真实 DOM更新，从而导致效率低）

2. 数据错位：新增input，新增的input还残留之前一个input绑定的数据 （如果结构中包含输入类的 DOM，会产生错误的 DOM 更新）

### 封装过的 vue 组件

1. 城市选择组件 搜索 首字母跳转
2. 全局封装注册图标组件 app.component
3. 表格、表单等

### vue 的 template 是怎么编译的
TODO:
1. vue template模板编译的过程经过parse()生成ast(抽象语法树),optimize对静态节点优化，generate()生成render字符串
2. 之后调用new Watcher()函数，用来监听数据的变化，render 函数就是数据监听的回调所调用的，其结果便是重新生成 vnode。
3. 当这个 render 函数字符串在第一次 mount、或者绑定的数据更新的时候，都会被调用，生成 Vnode。
4. 如果是数据的更新，那么 Vnode 会与数据改变之前的 Vnode 做 diff，对内容做改动之后，就会更新到我们真正的 DOM

### vue-router 的原理是什么

vue-router 的原理就是更新视图而不重新请求页面

Vue Router 的原理是通过拦截浏览器的默认行为，来实现页面跳转和组件切换的效果。当用户访问应用程序的某个链接时，Vue Router 会拦截这个请求，并根据路由规则，将对应的组件显示在视图中。这样，用户就可以在浏览器中操作应用程序，而无需刷新整个页面。

hash 模式和 history 模式都是通过 window.addEventListener() 方法监听 hashchange 和 popState 进行相应路由的操作。可以通过 back、foward、go 等方法访问浏览器的历史记录栈 进行各种跳转。

总的来说，Vue Router 的作用是解决 SPA 应用程序中路由和组件之间的关系，实现页面跳转和组件切换的效果。

### vue 的两种路由模式 hash 和 history

#### hash模式

1. hash模式是url后面带有#的情况，#后面的值不会包含在http请求，所有改变hash的值不会引起页面的重新加载，不会像服务器重新发起请求
2. 不利于seo优化
3. 只能修改#后面的部分，因此只能跳转与当前url同文档的url

hash原理： **onhashchange**事件，页面每次hash值得变化都会触发hashchange事件

会创建hashHistory对象，会被浏览器记录下来，在访问不同的路由会发生两种事件：hashHistory.push()：将新的路由添加到浏览器访问的历史栈顶，
hashHistory.replace()替换到当前栈

#### history模式

1. url不带#参数，看起来更美观
2. history模式依赖于前后端交互，即url修改就会请求后端url，如果后端没配置对应的/user/id的路由处理，就会返回404报错
3. history模式不仅可以在url里放参数，还可以将数据存放在一个特定的对象中，可以传递复杂的数据
4. 可以访问当前url同源的任意url
5. history原理：使用**window.onpopstate**监听浏览器地址，对浏览器 history api 中的 pushState()，replaceState()进行封装，当方法调用，会对浏览器的历史栈进行修改。从而实现 URL 的跳转而无需加载页面，但是它的问题在于当刷新页面的时候会走后端路由，所以需要服务端的辅助来完成，避免 url 无法匹配到资源时能返回页面。


### $route 和$router 的区别

$route 是"路由信息对象"，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数 (信息)
$router 是"路由实例(VueRouter)"对象，相当于一个全局的路由器对象,包括了路由的跳转方法，钩子函数等。如history对象，this.$router.push（）返回上一个history也是使用$router.go(-1)  (实例)

### 动态路由怎么获取传递的动态参数

场景：User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染
动态路径参数，使用“冒号”开头，一个路径参数，使用冒号标记，当匹配
到一个路由时，参数会被设置到 this.$route.params 中，并且可以在每个组件
中使用。
`{ path: '/user/:id', component: User }`
在匹配到该路由之后，动态参数会被设置到this.$route.params
```vue
template: '<div>User {{ $route.params.id }}</div>'
```
也可以是多个参数
`/user/:username/post/:post_id` 与路由一一对应

#### params和query的区别是什么

1. query 要用 path 来引入，params 需要用 name 来引入
2. 接收参数时，分别是`this.$route.query.name`  和 `this.$route.params.name` (注意：是`$route`而不是`$router`)
3. query 更加类似于我们 ajax 中 get 传参，params 则类似于 post，前者在浏览器的地址中显示，params 不显示
4. params 传值一刷新就没了，query 传值刷新还存在（因为是保存在地址栏中的）
   
### 路由传值的实现方式
共2种 params - name 和 query - path

#### query

```js
data:{
  username: ''
},
login() {
  ...
  this.$router.push({
    path: '/home',
    query: { username: this.username },
  })
}
```

#### params

```js
// 这边的name是给path取的别名，name最重要的一点就是配合params进行路由的参数传递
const routes = [
  {
    path: '/login',
    component: Login
  },
  {
    path: '/home',
    name: 'home',
    component: Home
  }
]

login() {
  this.$router.push({
    name: 'home',
    params: { username: this.username }
  })
}
```

### vue-router 的钩子函数 路由守卫
TODO:背
1. 全局钩子
   1. beforeEach  `router.beforeEach(to,from,next)`
   2. afterEach
   3. beforeResolve
2. 路由独享钩子
   1. beforeEnter  写在路由配置中，访问到这个路径会触发这个钩子函数
  ```js
  routes: [
    {
      path:'/foo',
      componenet: Foo,
      beforeEnter: (to,from,next) => {}
    }
  ]
  ```
3. 组件内钩子
   1. beforeRouterEnter 写在组件中，即将渲染组件的时候触发 不能访问this
   2. beforeRouterUpdate
   3. beforeRouterLeave
   ```js
   // 写在vue组件中
    beforeRouterLeave(to,from,next) {}
   ```

### vue 的 nextTick

nextTick: 将回调推迟到下一个 DOM 更新周期之后执行 
该钩子函数执行时所有的DOM挂载和渲染都已完成
#### 应用场景
1. 在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中
2. 在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中

### mixin 的用法

mixin 是用来分发 vue 组件中的可复用功能，可包含任意组件选项

#### 特点

1. 在被其他组件引入后，mixin中的方法和属性也就并入到该组件中
2. 数据对象在内部会进行递归合并，并在发生冲突时以**组件数据优先**
3. 同名钩子函数会被合并为一个数组，都被调用，**mixin的钩子先执行**
4. 也可以全局注入，不过会影响后面的所有vue实例，不建议

实战举例： e-charts的resize.js

### 虚拟 dom 的理解及其优点

虚拟DOM本质上是**JavaScript对象**,是对真实DOM的抽象 状态变更时，用对象记录新树和旧树的差异
最后把差异更新到真正的dom中

虚拟 DOM 主要的作用是**优化 DOM 的渲染性能**。在传统的网页开发中，当页面状态改变时，需要重新生成整个 DOM 树，这个过程非常耗时。而虚拟 DOM 把这个过程分为两个步骤：首先生成一颗虚拟 DOM 树，然后用虚拟 DOM 树和上一次生成的虚拟 DOM 树进行比较，找到差异，最后只对这些差异部分进行 DOM 操作。这个过程被称为“DOM Diff 算法”。

虚拟 DOM 本身是一个 JavaScript 对象，它包含了页面的结构信息和状态信息。通过使用虚拟 DOM，可以避免直接操作真实 DOM 树，从而提高渲染性能和用户体验。同时，虚拟 DOM 也提供了更好的抽象层，使得开发者可以更加方便地管理和维护页面状态。


#### 优点
1. 保证性能下限 大幅度减少了dom的操作，减少了重绘和回流的次数，提高了性能
2. 无需手动操作DOM virtualDOM的diff和patch都是在一次更新中自动进行的，无需手动操作
3. 跨平台 本质是js对象，dom是与平台强相关的，js对象可以更方便的跨平台操作

### 图片懒加载的实现

可以利用html5的属性data-xxx来保存图片的路径，当我们需要加载图片的时候才将data-xxx的值赋予src,就能实现图片的按需加载

vue-lazyload

### vue 中 data 数组的方法哪些不可以触发视图更新？不行的话怎么解决

1. 索引设置元素   `this.array[index] = newValue`
   1. 解决方式 `this.$set(this.array,index,newValue)` 或者 `this.array.splice(index,1,newValue)`
2. 直接修改数组长度 `this.array.length = newLength`
   1. 解决方式   `this.array.splice(newLength)`

### vue 底层是怎么实现对数组的监听的

在将数组处理成响应式数据后，如果使用数组原始方法改变数组时，数组值会发生变化，但是并不会触发数组的setter来通知所有依赖该数组的地方进行更新，为此，vue通过**重写数组的某些方法**来监听数组变化，重写后的方法中会手动触发通知该数组的所有依赖进行更新。

重写的数组方法：
push pop shift unshift splice sort reverse

### vue如何监听js报错

1. errorCaptured生命周期
2. window.onerror
3. errorHandler 全局错误处理 `app.config.errorHandler = function() {}`

### vuex
状态管理模式
#### 包含哪几种属性
- state  类似于vue的data mapState映射全局的state的getters到当前组件的computed中 `...mapState(['count'])`
- getters 是store的计算属性 可在多组件之间复用 `$store.getters.getter名`
- mutation 修改数据 类似methods `this.$store.commit('mutation名')`
- action 异步修改数据 `this.$store.dispatch('actions的名字', 参数)`
- module 模块拆分

```js
// 第二种访问方式
methods: {
  ...mapActions(['actionsName']),
  ...mapMutations(['mutationName'])
}
computed: {
  ...mapGetters(['xxx'])
}
```

### vuex 和 本地存储的区别

1. vuex存的是状态，存在**内存**中，localStorage是以文件的形式存储到**本地**
2. vuex用于组件之间的传值，localStorage则主要用于页面之间的传值
3. vuex可以做到数据的**响应**式，localStorage不行。即当两个组件共同用以数据源，如果其中一个组件中的数据源改变，希望另一个组件响应变化，这时候就要选择用vuex。
4. **当刷新页面时，vuex存储的值会丢失，localStorage不会**

### vue 踩过的坑

1. 给data中的对象直接添加属性并赋值 无效果 删除属性要用vue.delete
解决方法：Vue.$set(object, attribute, value)新增的属性也是响应式的
2. 在created中操作dom报错，无法获取到dom
解决方法：Vue.nextTick()
3. 内存泄漏 全局变量 自定义事件定时器等未销毁 
4. 路由切换时页面scroll到顶部 
   1. 从商品列表页进入到详情页后再返回列表页就会scroll到顶部
解决办法： 
在列表页缓存数据和scrollTop值 当再次返回列表页时，渲染组件执行scrollTo方法
mpa+app的new webview 两个页面 

### 如何统一监听vue组件报错

1. window.onerror 能全局监听所有js错误 但不能识别vue组件信息 window.addEventListener('error')
2. errorCaptured 在app.vue文件中写 可以监听所有子组件的报错
```js
errorCapturedL (err,vm,info) => {
  console.info('eeror',rr,vm,info);
  return false//可以阻止向上传播到window.error等
}
```
3. errorHandler main.js中配置 不会向上传播
```js
const app = createApp(App)
app.config.errorHandler = (error,vm,info) => {}
```
4. 异步错误 errorHandler捕获不到
可以用 全局onerror监听 也可以用unhandledrejection监听

### vue页面的渲染过程

1. 调用 compile 函数,生成 render 函数字符串 ,编译过程如下:
   1. parse 函数解析 template,生成 ast(抽象语法树) 
   2. optimizer 函数优化静态节点 (标记不需要每次都更新的内容,diff 算法会直接跳过静态节点,从而减少比较的过程,优化了 patch 的性能)
   3. generate 函数生成 render 函数字符串
2. 调用 new Watcher 函数,监听数据的变化,当数据发生变化时，Render 函数执行生成 vnode 对象
3. 调用 patch 方法,对比新旧 vnode 对象,通过 DOM diff 算法,添加、修改、删除真正的 DOM 元素

## 网络相关

### http状态码

1. 常见分类
1xx - 服务器收到请求。
2xx - 请求成功，如 200。
3xx - 重定向，如 302。
4xx - 客户端错误，如 404。
5xx - 服务端错误，如 500。

2. 常见状态码
200 - 成功。
301 - 永久重定向（配合 location，浏览器自动处理）。
302 - 临时重定向（配合 location，浏览器自动处理）。
304 - 资源未被修改。
403 - 没权限。
404 - 资源未找到。
500 - 服务器错误。
504 - 网关超时

### https比http的优势

安全性
1. https协议是由ssl+http协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性
2. 使用https协议可认证用户和服务器，确保数据发送到正确的客户机和服务器
seo
https在搜索结果中的排名会比http更高

### http工作原理

HTTP协议工作于客户端-服务端架构上，浏览器作为HTTP客户端通过URL向HTTP服务端发送所有请求。
#### 优点
1. 支持客户/服务器模式（请求应答模式）
2. 应用广泛且跨平台
3. 简单快速且灵活
4. 是可靠的传输协议

#### 缺点
1. 无状态
2. 无连接
3. 明文传输 调试遍历但信息易被窃取
4. 不安全 https引入ssl/tls解决这个问题

### 网络分层7层模型
应用层： 应用层、表示层、会话层（http ftp smtp dns）
传输层 （tcp和udp）
网络层 （ip）
物理和数据链路层 （以太网）

### TCP 三次握手和四次挥手

网络连接是TCP。传输内容是HTTP

第1次握手：客户端发送一个带有SYN（synchronize）标志的数据包给服务端；**我要传输**
第2次握手：服务端接收成功后，回传一个带有SYN/ACK标志的数据包传递确认信息，表示我收到了；**服务端收到**
第3次握手：客户端再回传一个带有ACK标志的数据包，表示我知道了，握手结束。**客户端收到**
其中：SYN标志位数置1，表示建立TCP连接；ACK标志表示验证字段

第1次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入FIN_WAIT_1状态； **我要断开**
第2次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务端进入CLOSE_WAIT状态； **好的收到，还有一个包**
第3次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入LAST_ACK状态； **我数据发送完了，随时关闭**
第4次挥手：客户端收到FIN后，客户端t进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，服务端进入CLOSED状态，完成四次挥手  **好的拜拜，你关闭吧，不用恢复**
A客户端等待2msl 无回复则关闭

理解：

三次握手之所以是三次是保证client和server均让对方知道自己的接收和发送能力没问题而保证的最小次数。

其中，为了保证后续的握手是为了应答上一个握手，每次握手都会带一个标识 seq，后续的ACK都会对这个seq进行加一来进行确认。

### HTTPS 的握手过程

https://blog.csdn.net/u012219045/article/details/100537007

1. 客户端发起HTTPS请求
2. 服务端的配置
3. 传送证书
4. 客户端解析证书
5. 传送加密信息
6. 服务段解密信息
7. 传输加密后的信息
8. 客户端解密信息

### Get 和 Post

1. GET是默认的HTTP请求方法 参数以key-value形式存放在url中，get更不安全，post是通过request body携带请求参数
2. get提交数据大小有限制，因为浏览器URL的长度有限制，post没有
3. get可以被缓存，post不能
4. get只允许ascii码，post没有限制

### 从 url 被输入到请求返回发生了什么

1. 输入 URL 后解析出协议、主机、端口、路径等信息，并构造一个 HTTP 请求。
   1. 强缓存
   2. 协商缓存
2. DNS 域名解析  域名转化为对应的ip
3. TCP 连接
> 总是要问：为什么需要三次握手，两次不行吗？其实这是由 TCP 的自身特点可靠传输决定的。客户端和服务端要进行可靠传输，那么就需要确认双方的接收和发送能力。第一次握手可以确认客服端的发送能力，第二次握手，确认了服务端的发送能力和接收能力，所以第三次握手才可以确认客户端的接收能力。不然容易出现丢包的现象。
4. HTTP 请求
5. 服务器处理请求并返回 HTTP 报文
6. 浏览器渲染页面（important）
   1. 先将HTML加载到浏览器的内部。
   2. 从上往下开始解析HTML。
   3. 当解析到引入的外部CSS文件时，另一个线程开始加载CSS文件，HTML继续解析。
   4. 浏览器解析DOM文档时，会将DOM文档解析成一棵树结构–DOM Tree，用来更清晰的显示出标签之间的层级关系。
   5. HTML解析完毕之后，等待CSS解析。
   6. CSS文件会被解析成CSS规则树(CSSOM Tree)，解析完毕之后会将每个节点的样式附加到DOM Tree形成布局树，最后再化为Render Tree （渲染树）
   7. 在渲染树(Render Tree)上运行布局(Layout) 以计算每个节点的几何体，然后将每个节点绘制 到屏幕上
7. 断开 TCP 连接

### 浏览器的渲染过程

上面

### 前端缓存的几种缓存方式

HTTP缓存和浏览器缓存
http缓存包括 强缓存和协商缓存 如上面
浏览器缓存分为本地存储 即cookie localStorage和sessionStorage 如上 

### ajax、axios、fetch的区别

#### ajax
Ajax 即“AsynchronousJavascriptAndXML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。

#### Fetch
fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的
fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。

#### Axios
Axios 是一种基于Promise封装的HTTP客户端

### web安全及防护

#### sql注入

举例： 
在输入框中输入SQL inject后面输入框填入' or 1=1 --
这样，前半句被单引号结束，后半句1=1恒成立，--将后续判断注释掉，导致不需要输入密码也能登录


通过SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令

防范措施：
1. 密码要加密存储
2. 使用框架及模板提交前检查代码输入内容
3. 所有输入的内容都要进行过滤

#### xss攻击 跨站脚本攻击

盗取用户的信息，如 cookie 

**反射型xss** 攻击者构造了特殊的 URL，当服务器接收到请求后，从 URL 中获取数据，拼接到 HTML 后返回，从而导致了恶意代码的执行。 举例：在url后面插入',alert('hha')，可以拿到cookie，在用更复杂的payload将cookie传给自己的服务器
**基于dom的xss** 攻击者构建了特殊的 URL，用户打开网站后，js 脚本从 URL 中获取数据，从而导致了恶意代码的执行。
**存储型xss** 恶意代码提交到了网站的数据库中，当用户请求数据的时候，服务器将其拼接为 HTML 后返回给了用户，从而导致了恶意代码的执行。举例：添加标签时插入onerror=alert(document.cookie)

防范措施：
1. 输入过滤，前端进行过滤之后后端在写入或访问数据库之前也要进行过滤
2. 在使用innerHtml和outerHtml和document.write等要特别小心，不可信的数据不能插到页面上 v-html也不推荐使用，js的eval()、setTimeout()、setInterval()等会将字符串转成代码运行也不推荐使用
3. 启用CSP（Content Security Policy） 内容安全策略
4. 还可以对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。

#### csrf 跨站请求伪造

引诱受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。
原理：利用cookie的自动携带特性，在其他的网站想你的网站发送请求，如果你的网站中没有退出登录，那么这次操作请求会被执行，比如银行转账途中点击其他网站。

特点：是冒充受害者提交操作
防范措施：
1. 同源检测 origin header
2. csrf token请求时携带token

## webpack 相关

### webpack的核心概念

1. Entry 入口，Webpack执行构建的第一步将从Entry开始，可抽象成输入
2. Output 出口，告诉Webpack在哪里输出它打包好的代码以及如何命名，
3. Module 模块，在Webpack里一切皆模块，一个模块对应着一个文件。Webpack会从配置的Entry开始递归找出所有依赖的模块
4. Chunk 代码块，一个Chunk由多个模块组合而成，用于代码合并与分割
5. Loader 模块转换器，用于把模块原内容按照需求转换成新内容
6. Plugin 扩展插件，在Webpack构建流程中的特定时机会广播出对应的事件，插件可以监听这些事件的发生，在特定时机做对应的事情。

### webpack的基本功能

1. 代码转化 ts编译成js，scss编译成css
2. 文件优化 压缩js css html代码
3. 代码分割 提取多页面的公共代码，提取首屏不需要执行部分的代码让其异步加载
4. 模块合并 在采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件
5. 自动刷新 自动构建，刷新浏览器
6. 代码校验 在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过
7. 自动发布 更新完代码后，自动构建出线上发布代码并传输给发布系统

### Webpack如何配置多入口文件

```js
entry: {
  home: resolve(__dirname, "src/home/index.js"),
  about: resolve(__dirname, "src/about/index.js")
}
```

### loader 和 plugin 区别

loader是**文件加载器**，能够加载资源文件，并对文件进行一些处理，如编译，压缩 等，最终一起打包到指定的文件中，loader运行在**项目打包**之前

plugin赋予了webpack各种灵活的**功能**，如打包优化，资源管理，环境变量，注入等，目的是为了解决loader无法实现的功能，plugins运行在整个项目的**编译**时期

### 常见 loader 

1. css-loader读取合并CSS文件
2. style-loader把CSS内容注入到JavaScript里
3. sass-loader解析sass文件（安装sass-loader，node-sass）
4. postcss-loader自动添加浏览器兼容前缀（postcss.config配置）
5. url-loader将文件转换为base64 URI。
6. vue-loader处理vue文件

### 常见 plugins 

1. HtmlWebpackPlugin自动在打包结束后生成html文件，并引入bundle.js
2. cleanwebPackPlugin打包自动删除上次打包文件
3. webpack-dev-server，开启开发服务器，监视文件变动
4. uglifyjs-webpack-plugin（js代码压缩混淆）
5. webpack-parallel-uglify-plugin 多进程执行代码压缩，提升构建速度。

### webpack 打包的流程

1. **初始化参数**  webpack.config.js中读取到对应的配置参数和shell命令中传入的参数进行合并得到最终打包配置参数
2. **编译准备** 这一步我们会通过调用webpack()方法返回一个compiler对象，并且注册各个Webpack Plugin。找到配置入口中的entry代码，调用compiler.run()方法进行编译
3. **模块编译** 从入口模块进行分析，调用匹配文件的loaders对文件进行处理。同时分析模块依赖的模块，递归进行模块编译工作
4. **完成编译** 在递归完成后，每个引用模块通过loaders处理完成同时得到模块之间的相互依赖关系
5. **输出文件** 整理模块依赖关系，同时将处理后的文件输出到ouput的磁盘目录中。

### webpack中的dev-server是怎么跑起来的

dev-server 是一个小型的 Node.js Express 服务器。

它使用了 **webpack-dev-middleware** 中间件来实现快速打包编译并通过 HTTP 服务提供打包后的文件。

dev-server 的运行流程如下：
1. 打包所有文件生成 JavaScript，并将它们存储在内存中;
2. 启动一个 HTTP 服务器，为应用程序提供服务;
3. 监听源代码文件的变化，当文件发生变化时重新编译它们;
4. 将编译后的文件重新加载到浏览器中，以实现实时重新加载和热模块替换。

### 实现webpack持久化缓存

hash 文件名是实现持久化缓存的第一步，目前 webpack 有两种计算 hash 的方式([hash] 和 [chunkhash])
- hash 代表每次 webpack 在编译的过程中会生成唯一的 hash 值，在项目中任何一个文件改动后就会被重新创建，然后 webpack 计算新的 hash 值。
- chunkhash 是根据模块计算出来的 hash 值，所以某个文件的改动只会影响它本身的 hash 值，不会影响其他文件。
如果你的项目涉及到拆包，分模块进行加载等等，那么你需要用 chunkhash，来保证每次更新之后只有相关的文件 hash 值发生改变。
一份具有持久化缓存的 webpack 配置应该长这样
```js
module.exports = {
 entry: __dirname + '/src/index.js',
 output: {
 path: __dirname + '/dist',
 filename: '[name].[chunkhash:8].js',
 }
}
```

第二种方法：
使用 hard-source-webpack-plugin 插件
```js
const HardSourceWebpackPlugin = require(&#39;hard-source-webpack-plugin&#39;);

module.exports = {
  // ...
  plugins: [
    new HardSourceWebpackPlugin()
  ]
};
```

### webpack中的source map是什么？生产环境怎么用？

首先前端项目在投入生产之前，都会对JavaScript源代码进行压缩混淆，从而减小文件的体积，提高文件的加载效率，也因此对压缩混淆之后的代码除错（debug） 是一件极其困难的事情
1. 变量被替换成没有任何语义的名称
2. 空行和注释被剔除

Source Map就是一个信息文件，里面储存着位置信息。也就是说，Source Map文件中存储着压缩混淆后的代码，所对应的转换前的位置。
出错的时候，除错工具将直接显示原始代码，而不是转换后的代码

#### 生产环境下

如果 省略了 devtool 选项 ，则最终生成的文件中 不包含 Source Map 。这能够 防止原始代码 通过 Source Map 的形式 暴露 给别有所图之人。

在生产环境下，如果 只想定位报错的具体行数 ，且 不想暴露源码 。此时可以将 devtool 的值设置为
**nosources-source-map**。

## typescript 和 vue3 相关

### ts比js的优势

ts是js的超集，在js的基础上添加了**类型系统**，用于强大的**静态类型检查**能力，并且继承了js的所有编程类型，js代码在ts环境也可以很好的运行

### vue2 和 vue3 的区别

1. 双向数据绑定的原理发生了改变 defineProperty和proxy
2. 最大区别： composition api组合式api 与 vue2的options api相比更简便和整洁
3. 生命周期钩子变了
```js
Vue2--------------vue3
beforeCreate  -> setup()
created       -> setup()
beforeMount   -> onBeforeMount
mounted       -> onMounted
beforeUpdate  -> onBeforeUpdate
updated       -> onUpdated
beforeDestroy -> onBeforeUnmount
destroyed     -> onUnmounted
activated     -> onActivated
deactivated   -> onDeactivated
```

## echarts

### echarts.js图表宽度自适应的问题

```js
// 单个图表
window.onresize = myChart.resize;   

//多个图标可以这样写：
window.onresize = () => {
    this.myChart.resize()
    this.myChart1.resize()
}
```

### echarts标签文字过多导致显示不全解决方案

#### echarts x轴标签文字过多导致显示不全

解决办法1：xAxis.axisLabel 属性
```js
  axisLabel: {  
    interval:0,  
    rotate:40  
  }  
```
解决办法2：调用formatter文字竖直显示 axisLabel的Formartter方法

## uniapp 相关

### 谈谈你对uniapp的理解

uni-app是一个使用vue.js开发所有前端应用的框架，开发编写一套代码，可以发布到多个平台
优点：
1. 跨平台
2. 运行体验良好
3. 开放生态，组件丰富
4. 通用技术栈
缺点：
1. 动画使用不方便，css动画多了会卡顿
2. 兼容性问题较多

### uni中如何为不同的平台设置不同的代码
1. 条件注释
以 #ifdef 或 #ifndef 加 %PLATFORM% 开头，以 #endif 结尾
`#ifdef APP-PLUS  ...$content...  #endif`

### uniapp中封装接口请求相较于微信小程序有什么要注意的

如果uniapp要在web端进行适配,要注意请求跨域问题—需要配置代理;可以通过在 vue.config.js 中配置Proxy代理解决
```js
devServer: {
  proxy: {
    '/api': {
      target: '',
      changeOrigin: true,
      pathRewrite: {
        '^/xxx-api': ''
      }
    }
  }
}
```

### uni-app中的本地存储数据和接收数据是什么

存储： uni.setStorageSync(‘name’,‘LZJAPYX,ZDL’);
获取： uni.getStorageSync(‘name’) // 以健名取键值
删除： uni.removeStorageSync(‘name’) // 删除该键名的数据
异步存储：
```js
// 存
uni.setStorage({
    key: "name",          // 键名
    data: "你好，word"      // 键值
});
// 取
uni.getStorage({
    key: "name",          // 键名
    success(res){
        console.log.(res.data)    // 你好，word
    }
});
// 删
uni.reomveStorage({
    key: "name",          // 键名
    success(res){
        console.log.(res)    // ok
    }
});

```

### uni-app 路由与页面跳转
1. uni.navigateTo({url: “/路径?参数=参数值”});	保留当前页面，只能跳转非tabBar页面
2. uni.switchTab({url: “/路径?参数=参数值”});	关闭所有非tabbar页面，只能打开tabbar页面
3. uni.redirectTo({url: “/路径?参数=参数值”});	关闭卸载当前页面，只能打开非tabBar页面
4. uni.reLaunch({url: “/路径?参数=参数值”});	关闭卸载所有页面，可以打开任意页面
5. uni.navigateBack({delta: 2});	返回上一页面 delta：返回页数
6. 标签< navigator >	open-type属性决定跳转方式
```js
<navigator url="../message/message?id=99">界面跳转传参</navigator>

//获取路由参数，在界面的onLoad方法中获取
onLoad(options) {
	console.log(options)
},
```

### uni-app全局变量怎么定义，怎么获取

在app.js中设置globalData设置，在需要的地方的js文件let app=getApp() app.globalData.数据

### uni中生命周期
- app页面
  - onLaunch	当uni-app 初始化完成时触发（全局只触发一次）
  - onShow	当 uni-app 启动，或从后台进入前台显示
  - onHide	当 uni-app 从前台进入后台
  - onError	当 uni-app 报错时触发
  - onUniNViewMessage	对 nvue 页面发送的数据进行监听
  - onUnhandledRejection	对未处理的 Promise 拒绝事件监听函数
  - onPageNotFound	页面不存在监听函数
  - onThemeChange	监听系统主题变化
- pages页面 [参考](https://blog.csdn.net/ytfty24124/article/details/128087256)
  - onInit
  - onLoad
  - onShow
  - onReady
  - onHide
  - onUnload
  - onResize
  - onPullDownRefresh
  - onReachBottom
  - onTabItemTop
- vue生命周期

### 提高微信小程序速度的方法
1. 控制代码包的大小：
   1. 代码包的体积压缩可以通过勾选开发者工具中“上传代码时，压缩代码”选项
   2. 及时清理无用的代码和资源文件
   3. 减少资源包中的图片等资源的数量和大小
2. 分包加载,预加载：
   1. 将用户访问率高的页面放在主包里，将访问率低的页面放入子包里，按需加载；采用子包预加载技术，并不需要等到用户点击到子包页面后在下载子包
3. 预请求：
   1. 请求可以在页面onLoad就加载，不需要等页面ready后在异步请求数据；尽量减少不必要的https请求，可使用 getStorageSync() 及 setStorageSync() 方法将数据存储在本地
4. 避免不当的使用setData：
   1. 不要过于频繁调用setData，应考虑将多次setData合并成一次setData调用
5. 使用自定义组件：
   1. 对于一些独立的模块我们尽可能抽离出来，这是因为自定义组件的更新并不会影响页面上其他元素的更新；各个组件也将具有各自独立的逻辑空间。每个组件都分别拥有自己的独立的数据、setData调用

## 性能优化相关

### 前端性能优化的措施 整理

前端面试题 第34题 可以参考

- html css js
  - **雪碧图 base64等减少请求数量**
  - **图片懒加载**
  - 使用webp格式的图片 **压缩html，css，js和图片**
  - 注意资源加载位置，加载时机，可添加异步script标签
  - 不使用css @import 会导致css无法并行下载，有个依赖顺序，会加长css解析延迟的时间
  - 能用css实现的效果就不要用js实现
  - 少用css表达式，计算评率太高
- dom相关
  - 给元素设置高度或者最小高度，以防页面晃动
  - 图片设置尺寸，不然从无到有会有回流
  - **需要多次重绘的元素开启GPU加速**  transform opacity filter
    - transform: translate3d(xx,xx,xx);
    - transform: translateZ(0); left这些每次都会触发repaint会有卡顿现象
  - 批量操作dom，减少dom操作次数，拼接完字符串再更新dom
  - **事件代理**
  - **防抖和节流**
- 网络相关
  - 使用**缓存**
  - **开启gzip压缩**
  - 使用cdn
- 打包相关
  - 打包公共代码 CommonsChunkPlugin插件
  - 动态导入和**按需加载**
  - 删除无用代码 treeShaking uglifyjs和purifyCSS

### h5页面首屏优化

1. 路由懒加载
   1. 适用于spa 
   2. 路由拆分
2. ssr服务器端渲染
   1. 如果是纯h5页面，ssr是性能优化的最佳方案 nuxtjs nextjs
3. app预取 app h5 jsbridge
4. 分页
   1. 针对列表页
   2. 默认只展示第一页内容
   3. 上划加载更多
5. 图片懒加载
   1. 针对详情页
   2. 默认只展示文本内容，然后触发图片懒加载
   3. 注意提前设置图片尺寸，尽量只重绘不重排

注意要 结合优化结果分析，比如优化完之后首屏渲染速度提升了0.5s

### vue 首屏加载优化方案

1. 使用cdn加载第三方库
2. 图片资源压缩（精灵图）和使用图片懒加载（虚拟列表可以讲讲）
3. vue-router路由懒加载
4. gzip压缩 webpack中使用compression-webpack-plugin插件
5. 移除 编译文件中的map文件 `productionSourceMap: false`
6. 代码层面优化 
   1. 合理使用v-if和v-show
   2. 记得及时销毁定时器 更多的参考上方前端性能优化

### 实际工作中做过哪些vue优化

1. v-if（彻底销毁）和v-show（css隐藏组件）
2. v-for使用key
3. computed缓存
4. keep-alive组件 如tabs
5. 把异步组件拆包出来 需要时异步加载 不需要的时候不加载 加快首页的加载 defineAsyncComponent
6. 路由懒加载 component `()=> import('xxx')`
7. ssr

### 前端seo优化有哪些
1. title description keywords权重逐渐减小，均要合理
2. 多用语义化标签
3. 重要html代码放前面
4. 少用iframe
5. 重要图片要加alt
6. 提高网站速度

## 其他

### vue组件封装原则

1. 单一原则
2. 多重职责
3. 明确接受参数
4. 可拓展

### 怎么从0到1构建一个vue项目

从0创建一个项目我大致会做以下事情：项目构建、引入必要插件、代码规范、提交规范、常用库和组件
1. 目前vue3项目我会用vite或者create-vue创建项目
2. 接下来引入必要插件：路由插件vue-router、状态管理vuex/pinia、ui库我比较喜欢
3. element-plus和antd-vue、http工具我会选axios
4. 其他比较常用的库有vueuse，nprogress，图标可以使用vite-svg-loader
5. 下面是代码规范：结合prettier和eslint即可
6. 最后是提交规范，可以使用husky，lint-staged，commitlint

### 前端工程化的理解

1. 将系统化的，规范化的方法用于前端应用的开发，运行和维护的过程
2. 用工程化方法构建和维护有效的，使用的高质量的前端应用

包含：开发 构建 部署 性能

，把 前端工程化 等同于 **效率工程**，认为一切能提升前端开发效率、提高前端应用质量的方法和工具都是前端工程化，我觉得这么理解也是没有问题的，提升开发效率、提升产品质量、降低开发难度、降低企业成本应该是工程化的意义所在。

#### 开发
框架选型
前后端分离
模块化
组件化
脚手架
组件库
本地开发服务器
Mock服务
微前端

#### 构建
依赖打包
文件压缩
代码分割
增量更新和缓存
资源定位
图标合并
Babel
CSS预编译
持续构建和集成
构建优化

#### 部署
持续部署
部署流程设计
静态资源部署策略
Nginx反向代理
SPA路由配置
跨域
https证书和http2
灰度发布

#### 性能
缓存策略
缓存复用
CDN内容分发网络
按需加载
同步异步加载
请求合并
首屏渲染速度
HTTP2服务器推送
日志性能监控
预加载
性能测试

#### 特点

- 模块化
- 组件化
- 规范化
- 自动化

### 单元测试相关

当前单元测试主要工具有Mocha和Jest
Mocha+Chai
Jest的写法：
```js
const sum = require('./sum');

describe('sum function test', () => {
  it('sum(1, 2) === 3', () => {
    expect(sum(1, 2)).toBe(3);
  });
  
  // 这里 test 和 it 没有明显区别，it 是指: it should xxx, test 是指 test xxx
  test('sum(1, 2) === 3', () => {
    expect(sum(1, 2)).toBe(3);
  });
})
```
配置test在package.json中
`scripts: {"test": "jest"}` npm run test即可

必须要用require的方式引用被测试方法，因为import是es6的模块化关键字

```js
import { fetchUser } from '../src/fetchUser';

test('fetchUser() 可以请求到一个用户名字为 moji', async () => {
  const data =  await fetchUser();

  expect(data.name).toBe('moji')
})
// 测试异步函数需要添加插件@babel/plugin-transform-runtime，因为默认babel/preset-env不支持async await
```

### svg的优势

svg是可伸缩矢量图形

1. svg图像可以被任意的文本编辑器创建和编辑
2. svg图像可以被搜索、索引化和脚本化，可压缩性更强
3. svg图像是可伸缩的
4. svg可在任何分辨率下被高质量打印 

### 后端如果一次性返回10万条数据，怎么渲染

1. 首先 这个设计不合理
2. 自定义nodejs中间层 获取并拆分这10w条数据 成本过高
3. 虚拟列表
   1. 只渲染可视区域DOM 其他都用空div撑起高度 借用第三方lib vue-virtual-scroll-list 不建议用，实现复杂且效果不一定好

### 前端常用的设计模式有哪些，并说明使用场景

- 开放封闭原则
   1. 对扩展开放
   2. 对修改封闭

1. 工厂模式
jQuery这种
```js
class Foo {}
function factory(a,b,c) {
  return new Foo()
}
```
2. 单例模式
```js
class SingleTon {
  private static instance: SingleTon | null = null
  private constructor() {}
  public static getInstance(): singleTon {
    if(this.instance === null) {
      this.instance = new SingleTon()
    }
    return this.instance
  }
}
const s = SingleTon.getInstance()
```
3. 代理模式 ES6 proxy
4. 观察者模式 addEventListener监听事件
5. 发布订阅模式 event.on event.emit()
6. 装饰器模式 原功能不变，增加一些新功能  Decorator

### 观察者模式和发布订阅模式的区别

subject和observer直接绑定没有中间媒介 ：addEventListern
Publisher和observer互不认识，需要中间媒介event channel ：EventBus
发布订阅模式相比观察者模式多了一个调度中心
发布订阅模式是在观察者模式的基础上做的优化升级。观察者模式是发布订阅模式的一种特殊实现
观察者和被观察者，是松耦合的关系
发布者和订阅者，则完全解耦

### 如果一个h5很慢，你该如何排查性能问题

- 前端性能指标 
  - first paint (fp)
  - first contentful paint (fp)
  - domContentload(dcl)
  - load(l)

用chrome的devtools的 performance 可以看到上述各指标的时间
性能分析工具 lighthouse

### 遇到最困难的问题是啥 怎么解决

动态换肤 scss变量
1. 对于 element-plus：因为 element-plus 是第三方的包，所以它 不是完全可控 的，那么对于这种最简单直白的方案，就是直接拿到它编译后的 css 进行色值替换，利用 style 内部样式表 优先级高于 外部样式表 的特性，来进行主题替换
   1. 获取当前elementplus的所有样式
   2. 定义我们要替换之后的样式
   3. 在原样式中，利用正则替换新样式
   4. 把替换后的样式写入到新style标签中
2. 对于自定义主题：因为自定义主题是 完全可控 的，所以我们实现起来就轻松很多，只需要修改对应的 scss变量即可

jsx实现无限层级

- 树形结构
- 表格行可拖拽


### 前端兼容性问题

回答方式 先描述2-3个兼容问题，最后一个总结
#### 问题

- ie6不支持min-height {min-height: 200px; _height: 350px;}
- IE6/7不支持display:inline-block  {display: inline-block; *display: inline;}
- IE9以下opacity不支持   Firefox/Chrome/Safari/Opera浏览器使用opacity；IE浏览器使用filter
- 图片加a标签在IE9中会有边框   img{border: none;}

1. 根据兼容需求选择技术框架/库(如 jquery 1.x.x )
2. 根据兼容需求选择兼容工具： html5shiv 、 Respond.js 、 CSS Reset 、 normalize.css 、 Modernizr.js 、 postcss
3. 条件注释、 CSS Hack 、 js 能力检测做一些修补。Hack ： CSS 中， Hack 是指一种兼容 CSS 在不同浏览器中正确显示的技巧方法，修补 bug 的方法Filter
：表示过滤器的意思，它是一种对特定的浏览器或浏览器组显示或隐藏规则或声明的方法。本质上讲， Filter 是 hack 方法中的一种。
4. 渐进增强和优雅降级（1）渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。（2）优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。

#### css hack
`*background-color:green` 在前面加*的只会对IE6，7生效，其他版本ie和现代浏览器会忽略这条指令
`-background-color:green`在前面加-的只会对IE6生效，其他版本ie和现代浏览器会忽略这条指令
后面添加“!important”的写法只有IE6不能识别，其它版本IE及现代浏览器都可以识别
区别IE 6.7.8
```css
.bb {
  background-color: #fff;
  .background-color: #fff; //ie6.7.8识别
  +background-color: #fff; //ie6.7识别
  _background-color: #fff; //ie6识别
}
```

### 移动端适配的问题

#### 2个概念：
自适应：根据不同的设备屏幕大小来自动调整尺寸，大小。
响应式：会随着屏幕的实时变动而自动调整，是一种自适应。

#### 4个方案
1. 百分比
2. rem+动态html的font-size  媒体查询设置不同html的根font-size
   1. 如果动态改变尺寸，不会实时的进行更新（没有实现响应式 lib-flexible） 可以用js动态获取屏幕宽度
3. vw单位  
   1. postcss-px-to-viewport
   2. 配置一下postcss.config.js即可 如下
4. flex

```js
// postcss.config.js
module.exports = {
  plugins: {
    'postcss-px-to-viewport': {
      viewportWidth: 375,
    },
  },
};
```

其中最推荐的就是vw方案
[参考](https://blog.csdn.net/weixin_57677300/article/details/129164050?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22129164050%22%2C%22source%22%3A%22weixin_57677300%22%7D)
### 断点续传

https://blog.csdn.net/Teemo_shape/article/details/105579955




[参考 1](https://juejin.cn/post/7031322059414175774)

[参考 2](https://juejin.cn/post/7061588533214969892)
